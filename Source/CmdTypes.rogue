module Boss

augment Cmd
  GLOBAL METHODS
    method common_type( a:Type, b:Type )->Type
      if (a is b) return a
      if (not a or not b) return null
      if (a.is_primitive and b.is_primitive)
        local type = Program.type_Value
        if (a is type or b is type) return type
        type = Program.type_String
        if (a is type or b is type) return type
        type = Program.type_Real64
        if (a is type or b is type) return type
        return Program.type_Int32  # any mismatched pair Logical/Character/Int32 -> Int32
      else
        return Program.type_String # Placeholder/TODO
      endIf

  METHODS
    method cmd_cast_to( target_type:Type )->Cmd
      local cur_type = require_type
      if (cur_type is target_type) return this
      return target_type.cmd_cast( this )

    method organize_element
      throw t.error( "[INTERNAL] $.organize_element() is undefined." (type_name) )

    method require_type->Type
      local result = type
      if (result) return result
      throw t.error( "Value expected." )

    method require_value->Cmd
      require_type
      return this

    method to->Type
      throw t.error( "[INTERNAL] $.to->Type is undefined." (type_name) )

    method type->Type
      return null
endAugment

# cmd_cast()
augment
  METHODS
    method Type.cmd_cast( cmd:Cmd )->Cmd
      return CastToObject( cmd.t, cmd, this )

    method TypeCharacter.cmd_cast( cmd:Cmd )->Cmd
      return CastToInt32(cmd.t,cmd)

    method TypeInt32.cmd_cast( cmd:Cmd )->Cmd
      return CastToInt32(cmd.t,cmd)

    method TypeLogical.cmd_cast( cmd:Cmd )->Cmd
      return CastToInt32(cmd.t,cmd)

    method TypeReal64.cmd_cast( cmd:Cmd )->Cmd
      return CastToReal64(cmd.t,cmd)

    method TypeString.cmd_cast( cmd:Cmd )->Cmd
      return CastToString(cmd.t,cmd)

    method TypeValue.cmd_cast( cmd:Cmd )->Cmd
      return CastToValue(cmd.t,cmd)
endAugment

# type()
augment
  METHODS
    method Unary.type->Type
      return operand.type

    method Binary.type->Type
      return common_type( left.type, right.type )

    method CallRoutine.type->Type
      return procedure.return_type

    method CastToInt32.type->Type
      return Program.type_Int32

    method CastToObject.type->Type
      return Program.type_Object

    method CastToReal64.type->Type
      return Program.type_Real64

    method CastToString.type->Type
      return Program.type_String

    method CastToValue.type->Type
      return Program.type_Value

    method DefineModule.organize_element
      if (Program.current_module.is_dynamic)
        local cur_name = Program.current_module.name
        if (cur_name != name)
          throw t.error( "Code from imported module '$' cannot switch module contexts."(cur_name) )
        endIf
      else
        Program.set_current_module( t, name )
      endIf

    method DescriptionInt32.type->Type
      return Program.type_String

    method DescriptionLogical.type->Type
      return Program.type_String

    method DescriptionObject.type->Type
      return Program.type_String

    method DescriptionReal64.type->Type
      return Program.type_String

    method GetLocal.type->Type
      return info.type

    method GetLocalValue.type->Type
      return Program.type_Value

    method ImportModule.type->Type
      return Program.type_Value

    method Include.organize_element
      Program.include( t, filepath )

    method LiteralString.type->Type
      return Program.type_String

    method LiteralLogical.type->Type
      return Program.type_Logical

    method LiteralCharacter.type->Type
      return Program.type_Character

    method LiteralInt32.type->Type
      return Program.type_Int32

    method LiteralReal64.type->Type
      return Program.type_Real64

    method LiteralPi.type->Type
      return Program.type_Real64

    method Routine.organize_element
      Program.current_module.routines.add( this )

    method Statements.organize_element
      Program.current_module.global_statements.add( this )

    method TypeReference.to->Type
      return Type( t, name )

    method UsesModule.organize_element
      use builder = StringBuilder.pool
        forEach (segment at i in path)
          if (i > 0) builder.print '/'
          builder.print segment->String
        endForEach
        local filepath = builder->String
        local m = Program.find_module( t, path.last->String )
        Program.current_module.uses_module( m, &=is_exported )
        Program.include( filepath, m )
      endUse

endAugment
