module Boss

class Program [singleton]
  DEFINITIONS
    EXE_CONTINUE  = 0
    EXE_ERROR     = 1
    EXE_RETURN    = 2

  GLOBAL PROPERTIES
    execution_status : Int32
    execution_result : BossValue
    execution_error  : Error

  PROPERTIES
    t              : Token

    is_configured  = false

    type_Logical   : Type
    type_Character : Type
    type_Int32     : Type
    type_Real64    : Type
    type_String    : Type
    type_Value     : Type

    type_Object    : Type
    type_Global    : Type
    type_XY        : Type

    parsed_files   = StringTable<<AST>>()

    default_module  : Module
    global_module   : Module
    current_module  : Module
    all_modules     = Module[]
    modules_by_name = StringTable<<Module>>()

    stack           = BossValue[]
    fp              : Int32

  METHODS
    method init
      Program = this # update singleton reference

      t = Token( TokenType.EOI, "Boss" )

      default_module = Module( t, "Default" )
      global_module  = Module( t, "Global" )
      default_module.uses_module( global_module )

      current_module = global_module
      type_Logical   = TypeLogical(t)
      type_Character = TypeCharacter(t)
      type_Int32     = TypeInt32(t)
      type_Real64    = TypeReal64(t)
      type_String    = TypeString(t)
      type_Value     = TypeValue(t)
      type_Object    = Type( t, "Object" )
      type_Global    = Type( t, "Global" )
      type_XY        = Type( t, "XY" ).[ is_built_in=true ]

      current_module = default_module

    method arg( index:Int32 )->BossValue
      return stack[ fp + index ]

    method create_dynamic_module( t:Token, name:String )->Module
      name = File.filename(name).before_last(".boss")
      return Module( t, name, &dynamic )

    method execute( procedure:Procedure, args:Cmd )->Logical
      local next_fp = stack.count
      if (args)
        forEach (arg in args)
          if (not arg.execute) return false
          stack.add( execution_result )
        endForEach
      endIf

      temporarily fp = next_fp
        stack.expand( procedure.local_stack_slots )
        procedure.statements.execute
        stack.discard_from( next_fp )
      endTemporarily

      which (execution_status)
        case EXE_CONTINUE: return true
        case EXE_RETURN:   execution_status = EXE_CONTINUE; return true
        others:            return false
      endWhich

    method execute( context:BossValue, procedure:Procedure, args:Cmd )->Logical
      local next_fp = stack.count
      stack.add( context )
      if (args)
        forEach (arg in args)
          if (not arg.execute) return false
          stack.add( execution_result )
        endForEach
      endIf

      temporarily fp = next_fp
        stack.expand( procedure.local_stack_slots )
        procedure.statements.execute
        stack.discard_from( next_fp )
      endTemporarily

      which (execution_status)
        case EXE_CONTINUE: return true
        case EXE_RETURN:   execution_status = EXE_CONTINUE; return true
        others:            return false
      endWhich

    method get_module( name:String )->Module
      return modules_by_name[ name ]

    method get_module( t:Token, name:String )->Module
      if (name is null)
        return default_module
      elseIf (modules_by_name.contains(name))
        return modules_by_name[ name ]
      else
        return Module( t, name )  # Module adds itself to lookup tables.
      endIf

    method find_type( name:String )->Type
      if (name.contains("::"))
        local m = get_module( name.before_first("::") )
        return m.find_type( name.after_first("::") )
      else
        local type = default_module.find_type( name, &extended_search )
        if (type) return type
        return null
      endIf

    method import( t:Token, filepath:String )->Logical
      try
        local m = create_dynamic_module( t, filepath )
        Program.include( filepath, m )
        return m.execute
      catch (err:Error)
        Program.execution_status = EXE_ERROR
        execution_error = err
        return false
      endTry

    method include( filepath:String, module_context=Program.default_module:Module )
      include( t, filepath, module_context )

    method include( t:Token, filepath:String, module_context=Program.default_module:Module )
      filepath .= with_trailing( ".boss" )

      local is_static = not module_context.is_dynamic
      if (is_static and parsed_files.contains(filepath)) return

      if (not File.exists(filepath))
        throw t.error( "No such file '$'."(filepath) )
      endIf

      filepath = File.abs( filepath )
      if (is_static and parsed_files.contains(filepath)) return

      # placeholders to avoid recursive includes
      if (is_static) parsed_files[ filepath ] = null

      temporarily current_module = module_context
        local tokens = Scanner( File(filepath) ).tokenize
        preprocess( tokens )

        local ast = Parser(tokens).parse->(as AST)
        if (is_static) parsed_files[ filepath ] = ast
        if (ast)
          Collector().visit( ast )
        endIf
      endTemporarily

    method launch
      resolve
      forEach (m in all_modules)
        m.execute
        if (execution_status == EXE_ERROR)
          if (not execution_error) execution_error = t.error( "[INTERNAL] Unknown error." )
          throw execution_error
        endIf
      endForEach
      require stack.is_empty
      require fp == 0

    method error( t:Token, message:String )->Logical
      execution_error = t.error( message )
      execution_status = EXE_ERROR
      return false

    method error_null_reference->Logical
      execution_error = Error( "Null reference access." )
      execution_status = EXE_ERROR
      return false

    method error_oob( index:Int32, limit:Int32 )->Logical
      execution_error = Error( "Out of bounds error accessing index $. Valid range is 0..$."(index,limit-1) )
      execution_status = EXE_ERROR
      return false

    method preprocess( tokens:Token[] )
      noAction

    method register( signature:String, handler:Function->BossValue )
      # signature
      #   routine_name(param1:Type1,param2=default_value:Type2,...)->ReturnType
      #   Module::routine_name(...)->ReturnType
      #   Type.method_name(...)->ReturnType
      #   Module::Type.method_name(...)->ReturnType
      #   Type:global_method_name(...)->ReturnType
      #   Module::Type:global_method_name(...)->ReturnType
      #
      # handler
      #   Can pull args with Program.arg(0), etc. arg(0) is the context object
      #   for methods or the first parameter for routines and global methods.
      #   If a procedure does not return a value (AKA "returns nil") then the
      #   handler should return BossValue() which is equivalent to 'undefined'.
      #
      #   The handler can throw an error or exception like this:
      #     Program.execution_status = EXE_ERROR
      #     Program.execution_error = Error(...)
      #     return BossValue()
      #
      # Examples
      #   Program.register(
      #     "Math:atan2(Real64,Real64)->Real64",
      #     () => Math.atan2( Program.arg(0), Program.arg(1) )
      #   )
      #
      #   Program.register( "Math:atan2(Real64,Real64)->Real64", (y,x) => Math:atan2(y,x) )
      local mod : Module
      if (signature.contains("::"))
        mod = get_module( signature.before_first("::") )
        signature .= after_first("::")
      else
        mod = default_module
      endIf

      local name = signature.before_first( '(' )
      signature .= from_first('(')
      if (name.contains(':'))
        # Global method
        local type = mod.type( name.before_first(':') )
        name .= after_first(':')
        local parser = Parser( "[$.$]"(type,name),"$$" (name,signature) )
        local m_def = parser.parse( Parser.ip_native_global_method )->(as GlobalMethodDef)
        local m = m_def->Method( type )
        m.statements.add( CallNative(m.t,handler) )
        type.augments.add( m )
      elseIf (name.contains('.'))
        # Method
        local type = mod.type( name.before_first('.') )
        name .= after_first('.')
        local parser = Parser( "[$.$]"(type,name),"$$" (name,signature) )
        local m_def = parser.parse( Parser.ip_native_method )->(as MethodDef)
        local m = m_def->Method( type )
        m.statements.add( CallNative(m.t,handler) )
        type.augments.add( m )
      else
        # Routine
        local parser = Parser( "[$]"(name),"$$" (name,signature) )
        local r_def = parser.parse( Parser.ip_native_routine )->(as RoutineDef)
        local r = r_def->Routine
        r.module_context = mod
        r.statements.add( CallNative(r.t,handler) )
        ensure mod.routines_by_name[ r.name ]
        mod.routines_by_name[ r.name ].add( r )
      endIf

    method resolve
      (forEach in all_modules).resolve

    method set_current_module( @current_module )

    method set_current_module( t:Token, name:String )
      if (name is null)
        @current_module = default_module
      elseIf (modules_by_name.contains(name))
        @current_module = modules_by_name[ name ]
      else
        @current_module = Module( t, name )
      endIf

    method type( name:String )->Type
      if (name.contains("::"))
        local m = get_module( name.before_first("::") )
        return m.type( name.after_first("::") )
      else
        return default_module.type( name )
      endIf

endClass

