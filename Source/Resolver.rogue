module Boss
uses Utility/WorkList

class Resolver : Visitor
  PROPERTIES
    this_module : Module
    this_type   : Type

  METHODS
    method init( this_module, this_type )

    method on( cmd:Access )->Cmd
      return resolve_access( null, cmd )

    method on( cmd:Add )->Cmd
      on_visit( cmd->(as Binary) )  # resolves children & converts to common type
      return visit( cmd.left.type.cmd_add(cmd.t, cmd.left, cmd.right) )

    method on_visit( cmd:Binary )
      visit_children( cmd )
      local left = cmd.left
      local right = cmd.right
      local left_type = left.require_type
      local right_type = right.require_type
      local result_type = Cmd.common_type( left_type, right_type )
      if (left_type is not result_type) cmd.left = visit( result_type.cmd_cast(left) )
      if (right_type is not result_type) cmd.right = visit( result_type.cmd_cast(right) )

    method on( cmd:CastToReal64 )->Cmd
      trace "TODO"
      #{
      local operand = visit( cmd.operand ).require_value
      local type = operand.type
      local t = cmd.t
      which (type.stack_type)
        case OpType.INT32:  return CastInt32ToReal64(t,operand)
        case OpType.REAL64: return operand
        case OpType.STRING: return CastStringToReal64(t,operand)
        others:             return CastObjectToReal64(t,operand)
      endWhich
      }#
      return cmd

    method on( cmd:Description )->Cmd
      local operand = visit( cmd.operand ).require_value
      return visit( operand.type.cmd_description(cmd.t, cmd.operand) )

    method on_visit( cmd:Statements )
      forEach (arg in rewriter=cmd.list.rewriter)
        arg = visit( arg )
        if (arg) rewriter.write( arg )
        #local type = arg.type
        #if (type) arg = type.cmd_stack_pop( arg )
      endForEach

    method on_visit( cmd:Print )
      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = visit( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach

      if (cmd.args.count == 0) throw cmd.t.error( "One or more arguments expected." )

    method on_leave( cmd:Println )
      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = visit( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach

    method on( cmd:Subtract )->Cmd
      on_visit( cmd->(as Binary) )  # resolves children & converts to common type
      return visit( cmd.left.type.cmd_subtract(cmd.t, cmd.left, cmd.right) )

    method resolve_access( context:Cmd, access:Access )->Cmd
      local match : Cmd
      use candidates = Candidates
        local name = access.name
        this_module.collect_routines( name, candidates.list )

        if (candidates.match)
          match = candidates.match
        else
          local mesg : String
          if (context)
            if (access.args) mesg = "No such method '$' exists in type '$'." (name,context.type)
            else             mesg = "No such property or method '$' exists in type '$'." (name,context.type)
          elseIf (this_type)
            if (access.args) mesg = "No such method or routine '$'."(access.name)
            else             mesg = "No such variable, method, or routine '$'."(name)
          else
            if (access.args) mesg = "No such routine '$'."(access.name)
            else             mesg = "No such variable or routine '$'."(access.name)
          endIf

          throw access.t.error( mesg )
        endIf
      endUse

      return visit( match.create_call(null,access.args) )
endClass

# Add
augment
  METHODS
    method Type.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be added."(name) )

    method TypeInt32.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddInt32( t, lhs, rhs )

    method TypeReal64.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddReal64( t, lhs, rhs )

    method TypeString.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddString( t, lhs, rhs )

endAugment

# Description
augment
  METHODS
    method Type.cmd_description( t:Token, operand:Cmd)->Cmd
      return DescriptionObject( t, operand )

    method TypeInt32.cmd_description( t:Token, operand:Cmd)->Cmd
      return DescriptionInt32( t, operand )

    method TypeLogical.cmd_description( t:Token, operand:Cmd)->Cmd
      return DescriptionLogical( t, operand )

    method TypeReal64.cmd_description( t:Token, operand:Cmd)->Cmd
      return DescriptionReal64( t, operand )

    method TypeString.cmd_description( t:Token, operand:Cmd)->Cmd
      return operand

endAugment

# Subtract
augment
  METHODS
    method Type.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be subtracted."(name) )

    method TypeInt32.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractInt32( t, lhs, rhs )

    method TypeReal64.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractReal64( t, lhs, rhs )

    method TypeString.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractString( t, lhs, rhs )

endAugment

