module Boss
uses Utility/WorkList

class Resolver : Visitor
  PROPERTIES
    this_module    : Module
    this_type      : Type
    this_procedure : Procedure

    current_statements_rewriter : ListRewriter<<Cmd>>

  METHODS
    method init( this_module )

    method visit( this_type )
      if (this_type.is_resolved) return
      this_type.is_resolved = true
      this_type.organize
      visit( this_type, forEach in this_type.methods )

    method visit( this_type, this_procedure )
      this_procedure.organize
      if (not this_procedure.is_resolved)
        this_procedure.is_resolved = true
        visit( this_procedure )
      endIf

    method on( cmd:Access )->Cmd
      cmd.args = visit( cmd.args )
      return resolve_access( cmd.t, null, cmd.name, cmd.args )

    method on_validate( cmd:Add )->Cmd
      return validate( cmd.left.type.cmd_add(cmd.t, cmd.left, cmd.right) )

    method on_visit( cmd:Binary )
      visit_children( cmd )
      local left = cmd.left
      local right = cmd.right
      local left_type = left.require_type
      local right_type = right.require_type
      local result_type = Cmd.common_type( left_type, right_type )
      if (left_type is not result_type) cmd.left = validate( result_type.cmd_cast(left) )
      if (right_type is not result_type) cmd.right = validate( result_type.cmd_cast(right) )

      #method on_visit( cmd:CallProcedure )
      #  if (cmd.args)
      #    forEach (arg at i in cmd.args)
      #      cmd.args[i] = visit(arg)
      #    endForEach
      #  endIf

    #method on_visit( cmd:CallRoutine )
      #on_visit( cmd->(as CallProcedure) )

    method on_validate( cmd:CastToReal64 )->Cmd
      trace "TODO"
      #{
      local operand = visit( cmd.operand ).require_value
      local type = operand.type
      local t = cmd.t
      which (type.stack_type)
        case OpType.INT32:  return CastInt32ToReal64(t,operand)
        case OpType.REAL64: return operand
        case OpType.STRING: return CastStringToReal64(t,operand)
        others:             return CastObjectToReal64(t,operand)
      endWhich
      }#
      return cmd

      #{
    method on_validate( cmd:CastToValue )->Cmd
      visit_children( cmd )
      local from_type = cmd.operand.require_type
      whichIs (from_type)
        others: throw
      endWhichIs
      }#

    method on( cmd:ContextAccess )->Cmd
      visit( cmd.args )
      return resolve_access( cmd.t, cmd.context, cmd.name, cmd.args )

    method on( cmd:Increment )->Cmd
      return cmd.operand.resolve_increment( cmd.t, this )

    method on_validate( cmd:IncrementLocal )->Cmd
      local type = cmd.info.type
      if (type is Program.type_Int32)
        return validate( IncrementLocalInt32(cmd.t,cmd.info) )
      else
        throw cmd.t.error( "[INTERNAL] Unhandled IncrementLocal for type $."(type) )
      endIf

    method on_validate( cmd:IncrementThisProperty )->Cmd
      local type = cmd.info.type
      if (type is Program.type_Int32)
        return validate( IncrementThisPropertyInt32(cmd.t,cmd.info) )
      else
        throw cmd.t.error( "[INTERNAL] Unhandled IncrementThisProperty for type $."(type) )
      endIf

    method on_visit( cmd:Local )
      if (not cmd.is_parameter)
        if (cmd.type)
          if (not cmd.initial_value) cmd.initial_value = cmd.type.cmd_default_value( cmd.t )
          cmd.initial_value = validate( visit(cmd.initial_value).cmd_cast_to( cmd.@type ) )
        elseIf (not cmd.@type)
          if (not cmd.initial_value)
            throw cmd.t.error( "Local variable declarations must have an initial value assignment or an assigned ': Type'." )
          endIf
          cmd.initial_value = visit( cmd.initial_value )
          cmd.type = cmd.initial_value.require_type
        else
          cmd.initial_value = visit( cmd.initial_value )
        endIf
      endIf

    method on_visit( cmd:Method )
      forEach (v in cmd.parameters step -1)
        block v = v->(as Local)
          if (v.is_auto_store)
            local p = this_type.must_find_property( cmd.t, v.name )
            cmd.statements.insert( visit( SetThisProperty(cmd.t, p, GetLocal(cmd.t,v)) ) )
          endIf
        endBlock
      endForEach
      visit_children( cmd )

    method on_visit( cmd:Print )
      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = validate( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach

      if (cmd.args.count == 0) throw cmd.t.error( "One or more arguments expected." )

    method on_visit( cmd:Println )
      visit_children( cmd )

      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = validate( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach

    method on_visit( cmd:Procedure )
      visit_children( cmd )

      #forEach (v at i in cmd.locals)
      #  v.fp_offset = i
      #endForEach

      cmd.local_stack_slots = cmd.locals.count
      if (cmd.parameters) cmd.local_stack_slots -= cmd.parameters.count
      # TODO: account for object context

    method on( cmd:Return )->Cmd
      if (cmd.result) return visit( ReturnResult(cmd.t,cmd.result) )
      return cmd

    method on_visit( cmd:ReturnResult )
      visit_children( cmd )
      cmd.result.require_value

    method on_visit( cmd:Statements )
      temporarily current_statements_rewriter = cmd.list.rewriter
        forEach (element in current_statements_rewriter)
          local visited_element = visit( element )
          if (visited_element) current_statements_rewriter.write( visited_element )
        endForEach
      endTemporarily

    method on_validate( cmd:Subtract )->Cmd
      return validate( cmd.left.type.cmd_subtract(cmd.t, cmd.left, cmd.right) )

    method on_visit( cmd:Unary )
      cmd.operand = visit( cmd.operand ).require_value

    method resolve_access( t:Token, context:Cmd, name:String, args:Cmd, &suppress_error )->Cmd
      if (context)
        context  = visit( context ).require_value
      else
        if (args)
          # Call or constructor
          local type = this_module.find_type( name, &extended_search )
          if (type)
            return validate( cmd_create_object(t,type,args) )
          endIf
        else
          local v = this_procedure.find_local( name )
          if (v) return validate( GetLocal(t,v) )
        endIf
      endIf

      local type_context = which{ context:context.require_type || this_type }
      local match = find_procedure( type_context, name, args )

      if (match)
        # TODO: fill in default values
        cast_args_to_parameter_types( args, match )
        return validate( match.cmd_call(context,args) )
      endIf

      if (not args)
        local p = type_context.find_property( name )
        if (p)
          if (context) return validate( GetProperty(t,context,p) )
          else         return validate( GetThisProperty(t,p) )
        endIf
      endIf

      if (suppress_error) return null

      local sig = name
      if (args)
        sig += '('
        forEach (arg at i in args)
          if (i > 0) sig += ','
          sig += arg.require_type
        endForEach
        sig += ')'
      endIf

      local mesg : String
      if (args)
        which (Candidates.count)
          case 0
            mesg = "No such "
            if (context)       mesg += "method "
            elseIf (this_type) mesg += "method or routine "
            else               mesg += "routine "

            if (context)       mesg += context.type + "."
            elseIf (this_type) mesg += this_type + "."

            mesg += sig + '.'

          case 1
            mesg = "Call to "
            if (context)       mesg += context.type + "."
            elseIf (this_type) mesg += this_type + "."

            mesg += sig
            mesg += " has arguments that are incompatible with the best candidate:\n\n"
            mesg += "  " + Candidates[0].context_signature

          others
            mesg = "Ambiguous call to "
            if (context)       mesg += context.type + "."
            elseIf (this_type) mesg += this_type + "."

            mesg += sig
            mesg += ". Candidates:\n\n"
            forEach (m in Candidates)
              mesg += "  " + m.context_signature
            endForEach

        endWhich

      else
        if (context)
          if (args) mesg = "No such method '$' exists in type '$'." (sig,context.type)
          else      mesg = "No such property or method '$' exists in type '$'." (sig,context.type)
        elseIf (this_type)
          if (args) mesg = "No such method or routine '$'."(sig)
          else      mesg = "No such variable, method, or routine '$'."(sig)
        else
          if (args) mesg = "No such routine '$'."(sig)
          else      mesg = "No such variable or routine '$'."(sig)
        endIf
      endIf

      throw t.error( mesg )

    method cmd_create_object( t:Token, type_context:Type, args:Cmd )->Cmd
      local m_init = find_procedure( type_context, "init", args )
      if (m_init)
        cast_args_to_parameter_types( args, m_init )
        return CreateObject( t, type_context, m_init, args )
      else
        local mesg : String
        use Candidates
          type_context.collect_methods( "create", Candidates.list )
          type_context.collect_methods( "init", Candidates.list )

          if (args.count == 0 and Candidates.count == 0)
            # No constructors available and no constructor required.
            return CreateObject( t, type_context, null, null )
          endIf

          mesg = "No exact match for object constructor $("(type_context)
          forEach (arg at i in args)
            if (i > 0) mesg += ','
            mesg += arg.require_type
          endForEach
          mesg += "). Candidates:\n\n"
          if (Candidates.count)
            forEach (m in Candidates)
              mesg += "  $$" (type_context,m.signature.from_first('('))
            endForEach
          else
            mesg += "  $()"(type_context)
          endIf
        endUse
        throw t.error( mesg )
      endIf

    method cast_args_to_parameter_types( args:Cmd, proc:Procedure )
      if (not args) return
      forEach (arg at i in args)
        args[i] = validate( arg.cmd_cast_to(proc.parameters[i].type) )
      endForEach

    method find_procedure( type_context:Type, name:String, args:Cmd )->Procedure
      visit( args )  # resolve args to determine types
      use Candidates
        if (type_context)
          type_context.collect_methods( name, Candidates.list )
        else
          this_module.collect_routines( name, Candidates.list )
        endIf
        return refine_candidates( type_context, args )
      endUse

    method refine_candidates( type_context:Type, args:Cmd )->Procedure
      local arg_count = which{ args:args.count || 0 }
      forEach (m in Candidates)
        if (m.accepts_arg_count(arg_count)) Candidates.keep m
      endForEach
      if (Candidates.found_match) return Candidates.match
      if (not Candidates.refine) return null

      return null
endClass

augment Procedure
  PROPERTIES
    local_stack_slots : Int32  # in addition to args already on stack

  METHODS
    method find_local( name:String )->Local
      forEach (v in locals step -1)
        if (v.name == name) return v
      endForEach
      return null
endAugment

# Add
augment
  METHODS
    method Type.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be added."(name) )

    method TypeInt32.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddInt32( t, lhs, rhs )

    method TypeReal64.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddReal64( t, lhs, rhs )

    method TypeString.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddString( t, lhs, rhs )

    method TypeValue.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddValue( t, lhs, rhs )

endAugment

# Call
augment
  METHODS
    method Cmd.cmd_call( context:Cmd, args:Cmd )->Cmd
      throw t.error( "[INTERNAL] $.cmd_call() is undefined."(type_name) )

    method Method.cmd_call( context:Cmd, args:Cmd )->Cmd
      if (context) return CallMethod( t, context, this, args )
      else         return CallThisMethod( t, this, args )

    method Routine.cmd_call( context:Cmd, args:Cmd )->Cmd
      return CallRoutine( t, this, args )
endAugment

# Increment
augment
  METHODS
    method Cmd.resolve_increment( t:Token, resolver:Resolver )->Cmd
      throw t.error( "Illegal target for increment." )

    method Access.resolve_increment( t:Token, resolver:Resolver )->Cmd
      if (not args)
        local v = resolver.this_procedure.find_local( name )
        if (v) return resolver.validate( IncrementLocal(t,v) )

        local p = resolver.this_type.find_property( name )
        if (p) return resolver.validate( IncrementThisProperty(t,p) )
      endIf
      throw t.error( "Illegal target for increment." )

      #method Access.resolve_increment( t:Token, resolver:Resolver )->Cmd
      #return CallRoutine( t, this, args )
endAugment

# Description
augment
  METHODS
    method Type.cmd_description( t:Token, operand:Cmd)->Cmd
      return Description( t, operand )
endAugment

# Subtract
augment
  METHODS
    method Type.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be subtracted."(name) )

    method TypeInt32.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractInt32( t, lhs, rhs )

    method TypeReal64.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractReal64( t, lhs, rhs )

    method TypeString.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractString( t, lhs, rhs )

endAugment

