module Boss
uses Utility/WorkList

class Resolver : Visitor
  PROPERTIES
    this_module    : Module
    this_type      : Type
    this_procedure : Procedure

  METHODS
    method init( this_module, this_type, this_procedure )

    method on( cmd:Access )->Cmd
      return resolve_access( null, cmd )

    method on( cmd:Add )->Cmd
      on_visit( cmd->(as Binary) )  # resolves children & converts to common type
      return visit( cmd.left.type.cmd_add(cmd.t, cmd.left, cmd.right) )

    method on_visit( cmd:Binary )
      visit_children( cmd )
      local left = cmd.left
      local right = cmd.right
      local left_type = left.require_type
      local right_type = right.require_type
      local result_type = Cmd.common_type( left_type, right_type )
      if (left_type is not result_type) cmd.left = visit( result_type.cmd_cast(left) )
      if (right_type is not result_type) cmd.right = visit( result_type.cmd_cast(right) )

    method on_visit( cmd:CallProcedure )
      if (cmd.args)
        forEach (arg at i in cmd.args)
          cmd.args[i] = visit(arg)
        endForEach
      endIf

    method on_visit( cmd:CallRoutine )
      on_visit( cmd->(as CallProcedure) )

    method on( cmd:CastToReal64 )->Cmd
      trace "TODO"
      #{
      local operand = visit( cmd.operand ).require_value
      local type = operand.type
      local t = cmd.t
      which (type.stack_type)
        case OpType.INT32:  return CastInt32ToReal64(t,operand)
        case OpType.REAL64: return operand
        case OpType.STRING: return CastStringToReal64(t,operand)
        others:             return CastObjectToReal64(t,operand)
      endWhich
      }#
      return cmd

      #{
    method on( cmd:CastToValue )->Cmd
      visit_children( cmd )
      local from_type = cmd.operand.require_type
      whichIs (from_type)
        others: throw
      endWhichIs
      }#

    method on( cmd:Description )->Cmd
      local operand = visit( cmd.operand ).require_value
      return visit( operand.type.cmd_description(cmd.t, cmd.operand) )

    method on( cmd:GetLocal )->Cmd
      local type = cmd.info.type
      if (type is Program.type_Value)
        return visit( GetLocalValue(cmd.t,cmd.info) )
      else
        throw cmd.t.error( "[INTERNAL] Resolver.on(GetLocal) does not handle type $."(cmd.info.type) )
      endIf

    method on( cmd:GetLocalValue )->Cmd
      return cmd

    method on_visit( cmd:Statements )
      forEach (arg in rewriter=cmd.list.rewriter)
        arg = visit( arg )
        if (arg) rewriter.write( arg )
        #local type = arg.type
        #if (type) arg = type.cmd_stack_pop( arg )
      endForEach

    method on_visit( cmd:Print )
      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = visit( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach

      if (cmd.args.count == 0) throw cmd.t.error( "One or more arguments expected." )

    method on_leave( cmd:Println )
      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = visit( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach

    method on_leave( cmd:Procedure )
      forEach (v at i in cmd.locals)
        v.index = i
      endForEach

    method on( cmd:Return )->Cmd
      if (cmd.result) return visit( ReturnResult(cmd.t,cmd.result) )
      return cmd

    method on_leave( cmd:ReturnResult )
      cmd.result.require_value

    method on( cmd:Subtract )->Cmd
      on_visit( cmd->(as Binary) )  # resolves children & converts to common type
      return visit( cmd.left.type.cmd_subtract(cmd.t, cmd.left, cmd.right) )

    method resolve_access( context:Cmd, access:Access )->Cmd
      local match : Procedure

      if (not context and not access.args and this_procedure)
        local v = this_procedure.find_local( access.name )
        if (v) return visit( GetLocal(access.t,v) )
      endIf

      visit( access.args )  # resolve args to determine types

      use Candidates
        local name = access.name
        this_module.collect_routines( name, Candidates.list )

        match = refine_candidates( context, access )

        if (not match)
          local sig = name
          if (access.args)
            sig += '('
            forEach (arg at i in access.args)
              if (i > 0) sig += ','
              sig += arg.require_type
            endForEach
            sig += ')'
          endIf

          local mesg : String
          if (access.args)
            which (Candidates.count)
              case 0
                mesg = "No such "
                if (context)       mesg += "method "
                elseIf (this_type) mesg += "method or routine "
                else               mesg += "routine "

                if (context)       mesg += context.type + "."
                elseIf (this_type) mesg += this_type + "."

                mesg += sig + '.'

              case 1
                mesg = "Call to "
                if (context)       mesg += context.type + "."
                elseIf (this_type) mesg += this_type + "."

                mesg += sig
                mesg += " has arguments that are incompatible with the best candidate:\n\n"
                mesg += "  " + Candidates[0].context_signature

              others
                mesg = "Ambiguous call to "
                if (context)       mesg += context.type + "."
                elseIf (this_type) mesg += this_type + "."

                mesg += sig
                mesg += ". Candidates:\n\n"
                forEach (m in Candidates)
                  mesg += "  " + m.context_signature
                endForEach

            endWhich
          else
            if (context)
              if (access.args) mesg = "No such method '$' exists in type '$'." (sig,context.type)
              else             mesg = "No such property or method '$' exists in type '$'." (sig,context.type)
            elseIf (this_type)
              if (access.args) mesg = "No such method or routine '$'."(sig)
              else             mesg = "No such variable, method, or routine '$'."(sig)
            else
              if (access.args) mesg = "No such routine '$'."(sig)
              else             mesg = "No such variable or routine '$'."(sig)
            endIf
          endIf

          throw access.t.error( mesg )
        endIf
      endUse

      # TODO: fill in default values

      # Cast args to parameter types
      if (access.args)
        forEach (arg at i in access.args)
          access.args[i] = arg.cmd_cast_to( match.parameters[i].type )
        endForEach
      endIf

      return visit( match.cmd_call(null,access.args) )

    method refine_candidates( context:Cmd, access:Access )->Procedure
      local arg_count = which{ access.args:access.args.count || 0 }
      forEach (m in Candidates)
        if (m.accepts_arg_count(arg_count)) Candidates.keep m
      endForEach
      if (Candidates.found_match) return Candidates.match
      if (not Candidates.refine) return null

      return null
endClass

augment Procedure
  METHODS
    method find_local( name:String )->Local
      forEach (v in locals step -1)
        if (v.name == name) return v
      endForEach
      return null
endAugment

augment Cmd
  METHODS
    method cmd_call( context:Cmd, args:Cmd )->Cmd
      throw t.error( "[INTERNAL] $.cmd_call() is undefined."(type_name) )

endAugment

# Add
augment
  METHODS
    method Type.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be added."(name) )

    method TypeInt32.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddInt32( t, lhs, rhs )

    method TypeReal64.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddReal64( t, lhs, rhs )

    method TypeString.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddString( t, lhs, rhs )

    method TypeValue.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddValue( t, lhs, rhs )

endAugment

# Call
augment
  METHODS
    method Routine.cmd_call( context:Cmd, args:Cmd )->Cmd
      return CallRoutine( t, this, args )
endAugment

# Description
augment
  METHODS
    method Type.cmd_description( t:Token, operand:Cmd)->Cmd
      return DescriptionObject( t, operand )

    method TypeInt32.cmd_description( t:Token, operand:Cmd)->Cmd
      return DescriptionInt32( t, operand )

    method TypeLogical.cmd_description( t:Token, operand:Cmd)->Cmd
      return DescriptionLogical( t, operand )

    method TypeReal64.cmd_description( t:Token, operand:Cmd)->Cmd
      return DescriptionReal64( t, operand )

    method TypeString.cmd_description( t:Token, operand:Cmd)->Cmd
      return operand

    method TypeValue.cmd_description( t:Token, operand:Cmd)->Cmd
      return DescriptionValue( t, operand )

endAugment

# Subtract
augment
  METHODS
    method Type.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be subtracted."(name) )

    method TypeInt32.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractInt32( t, lhs, rhs )

    method TypeReal64.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractReal64( t, lhs, rhs )

    method TypeString.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractString( t, lhs, rhs )

endAugment

