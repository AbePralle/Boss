module Boss
uses Utility/WorkList

class Resolver : Visitor
  PROPERTIES
    cur_module : Module

  METHODS
    method init( cur_module )

    method on( cmd:Access )->Cmd
      return resolve_access( null, cmd )

    method on( cmd:Add )->Cmd
      on_visit( cmd as Binary )  # resolves children & converts to common type
      local t = cmd.t
      which (cmd.left.type.op_type)
        case OpType.INT32:  return AddInt32(t,cmd.left,cmd.right)
        case OpType.REAL64: return AddReal64(t,cmd.left,cmd.right)
        case OpType.STRING: return AddString(t,cmd.left,cmd.right)
        case OpType.OBJECT: return AddObject(t,cmd.left,cmd.right)
        others:             throw t.error( "TODO: Add LOGICAL" )
      endWhich

    method on_visit( cmd:Binary )
      visit_children( cmd )
      local left = cmd.left
      local right = cmd.right
      local left_type = left.require_type
      local right_type = right.require_type
      local result_type = Cmd.common_type( left_type, right_type )
      if (left_type is not result_type) cmd.left = visit( result_type.cmd_cast(left) )
      if (right_type is not result_type) cmd.right = visit( result_type.cmd_cast(right) )

    method on( cmd:CastToReal64 )->Cmd
      local operand = visit( cmd.operand ).require_value
      local type = operand.type
      local t = cmd.t
      which (type.stack_type)
        case OpType.INT32:  return CastInt32ToReal64(t,operand)
        case OpType.REAL64: return operand
        case OpType.STRING: return CastStringToReal64(t,operand)
        others:             return CastObjectToReal64(t,operand)
      endWhich

    method on( cmd:Description )->Cmd
      local operand = visit( cmd.operand ).require_value
      local type = operand.type
      local t = cmd.t
      which (type.op_type)
        case OpType.INT32:  return DescriptionInt32(t,operand)
        case OpType.REAL64: return DescriptionReal64(t,operand)
        case OpType.STRING: return operand
        case OpType.OBJECT: return DescriptionObject(t,operand)
        others:             return DescriptionLogical(t,operand)
      endWhich

    method on_visit( cmd:Statements )
      forEach (arg in rewriter=cmd.list.rewriter)
        arg = visit( arg )
        if (arg) rewriter.write( arg )
        #local type = arg.type
        #if (type) arg = type.cmd_stack_pop( arg )
      endForEach

    method on_visit( cmd:Print )
      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = visit( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach

      if (cmd.args.count == 0) throw cmd.t.error( "One or more arguments expected." )

    method on_leave( cmd:Println )
      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = visit( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach

    method on( cmd:Subtract )->Cmd
      on_visit( cmd as Binary )  # resolves children & converts to common type
      local t = cmd.t
      which (cmd.left.type.op_type)
        case OpType.INT32:  return SubtractInt32(t,cmd.left,cmd.right)
        case OpType.REAL64: return SubtractReal64(t,cmd.left,cmd.right)
        case OpType.STRING: return SubtractString(t,cmd.left,cmd.right)
        case OpType.OBJECT: return SubtractObject(t,cmd.left,cmd.right)
        others:             throw t.error( "TODO: Subtract LOGICAL" )
      endWhich

    method resolve_access( context:Cmd, access:Access )->Cmd
      local name = access.name

      #use candidates=WorkList<<

      local mesg : String
      if (access.args)
        if (context) mesg = "No such method '$' exists in type '$'." (name,context.type)
        else         mesg = "No such variable, method, or routine '$'."(access.name)
      else
        if (context)
          mesg = "No such variable or method '$' exists in type '$'." (name,context.type)
        else
          mesg = "No such variable, method, or routine '$'."(name)
        endIf
      endIf
      throw access.t.error( mesg )
endClass

