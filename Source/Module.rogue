module Boss

class Module
  PROPERTIES
    t    : Token
    name : String

    used_modules      = UsedModule[]
    types             = StringTable<<Type>>()
    global_statements : Statements
    routines          = Procedures()

    is_visiting : Logical

  METHODS
    method init( t, name )
      global_statements = Statements(t)
      Program.all_modules.add( this )
      Program.modules_by_name[ name ] = this

    method analyze( visitor:Visitor )
      visitor.visit( forEach in (forEach in routines.by_name) )
      visitor.visit( global_statements )

    method collect_routines( m_name:String, list:Procedure[], &is_limited )
      if (is_visiting) return

      local matching = routines.by_name[ m_name ]
      if (matching) list.add( matching )

      is_visiting = true
      forEach (used_m in used_modules)
        if (not is_limited or used_m.is_exported)
          used_m.m.collect_routines( m_name, list, &=is_limited )
        endIf
      endForEach
      is_visiting = false

    method find_type( name:String, &is_limited )->Type
      if (is_visiting) return null

      local result = types[ name ]
      if (result) return result

      is_visiting = true
      forEach (used_m in used_modules)
        if (not is_limited or used_m.is_exported)
          result = used_m.m.find_type( name, &is_limited )
          if (result) escapeForEach
        endIf
      endForEach
      is_visiting = false

      return result

    method launch
      local statements = global_statements
      global_statements = Statements(t)
      statements.execute

    method must_find_type( t:Token, name:String )->Type
      local result = find_type( name )
      if (result) return result
      throw t.error( "No such type '$'." (name) )

    method organize_types
      # TODO: arrange class inheritance

    method organize_methods
      analyze( MethodOrganizer(this) )

    method resolve
      analyze( Resolver(this,null) )

    method use_module( m:Module, &is_exported )
      if (m is this) return # happens when this is the default module
      forEach (existing_m in used_modules)
        if (existing_m.m is m) return
      endForEach
      used_modules.add( UsedModule(m,&=is_exported) )

endClass

class UsedModule( m:Module, is_exported:Logical ) [compound]
endClass

