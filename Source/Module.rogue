module Boss

class Module
  ENUMERATE
    STATE_UNRESOLVED
    STATE_TYPES_ORGANIZED
    STATE_METHODS_ORGANIZED
    STATE_RESOLVED

  PROPERTIES
    t    : Token
    name : String

    used_modules          = UsedModule[]
    types                 = StringTable<<Type>>()
    global_statements     : Statements
    routines_by_name      = StringTable<<Routine[]>>()
    routines_by_signature = StringTable<<Routine>>()

    is_dynamic   : Logical
    is_visiting  : Logical
    is_resolving : Logical

    state = STATE_UNRESOLVED : Int32

  METHODS
    method init( t, name, &dynamic )
      global_statements = Statements(t)
      is_dynamic = dynamic
      Program.all_modules.add( this )
      if (not is_dynamic) Program.modules_by_name[ name ] = this

    method collect_routines( m_name:String, list:Procedure[], &is_limited )
      if (is_visiting) return

      local matching = routines_by_name[ m_name ]
      if (matching) list.add( forEach in matching )

      temporarily is_visiting = true
        forEach (used_m in used_modules)
          if (not is_limited or used_m.is_exported)
            used_m.m.collect_routines( m_name, list, &=is_limited )
          endIf
        endForEach
      endTemporarily

    method description->String
      return name

    method execute->Logical
      if (not global_statements.count)
        Program.execution_status = Program.EXE_RETURN
        Program.execution_result = BossValue()
        return true
      endIf

      #local statements = global_statements
      #global_statements = Statements(t)

      local r_launch = Routine( t, "global_statements", null, null, null, global_statements )
      MethodOrganizer(this,r_launch).visit( r_launch )
      Resolver(this,null,r_launch).visit( r_launch )
      if (Program.execute( r_launch, null )) return true
      return false

    method find_type( name:String, &extended_search )->Type
      if (is_visiting) return null

      local result = types[ name ]
      if (result) return result

      temporarily is_visiting = true
        forEach (used_m in used_modules)
          if (extended_search or used_m.is_exported)
            result = used_m.m.find_type( name, &!extended_search )
            if (result) escapeForEach
          endIf
        endForEach
      endTemporarily

      return result

    method must_find_type( t:Token, name:String )->Type
      local result = find_type( name )
      if (result) return result
      throw t.error( "No such type '$'." (name) )

    method organize_types
      if (is_resolving) return
      if (state >= STATE_TYPES_ORGANIZED) return
      state = STATE_TYPES_ORGANIZED

      temporarily is_resolving = true
        TypeOrganizer( this ).visit( forEach in types.values )
      endTemporarily

    method organize_methods
      if (is_resolving) return
      if (state >= STATE_METHODS_ORGANIZED) return
      organize_types
      state = STATE_METHODS_ORGANIZED

      temporarily is_resolving = true
        forEach (r in (forEach in routines_by_name))
          MethodOrganizer(this,r).visit( r )
        endForEach
      endTemporarily

    method resolve
      if (is_resolving) return
      if (state >= STATE_RESOLVED) return
      organize_methods
      state = STATE_RESOLVED

      temporarily is_resolving = true
        forEach (r in (forEach in routines_by_name))
          Resolver(this,null,r).visit( r )
        endForEach
        Resolver( this, null, null ).visit( forEach in types.values )
      endTemporarily

    method uses_module( m:Module, &is_exported )
      if (m is this) return # happens when this is the default module
      forEach (existing_m in used_modules)
        if (existing_m.m is m) return
      endForEach
      used_modules.add( UsedModule(m,&=is_exported) )

endClass

class UsedModule( m:Module, is_exported:Logical ) [compound]
endClass

