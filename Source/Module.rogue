module Boss

class Module
  BOSS_ATTRIBUTE( is_dynamic,   1 )
  BOSS_ATTRIBUTE( is_organized, 2 )
  BOSS_ATTRIBUTE( is_resolved,  4 )
  BOSS_ATTRIBUTE( is_visiting,  8 )

  PROPERTIES
    t    : Token
    name : String

    used_modules          = UsedModule[]
    types                 = StringTable<<Type>>()
    global_statements     : Statements
    routines_by_name      = StringTable<<Routine[]>>()
    routines_by_signature = StringTable<<Routine>>()

    attributes : Int32

  METHODS
    method init( t, name, &dynamic )
      global_statements = Statements(t)
      is_dynamic = dynamic
      Program.all_modules.add( this )
      if (not is_dynamic) Program.modules_by_name[ name ] = this

    method collect_routines( m_name:String, list:Procedure[], &is_limited )
      if (is_visiting) return

      local matching = routines_by_name[ m_name ]
      if (matching) list.add( forEach in matching )

      temporarily is_visiting = true
        forEach (used_m in used_modules)
          if (not is_limited or used_m.is_exported)
            used_m.m.collect_routines( m_name, list, &=is_limited )
          endIf
        endForEach
      endTemporarily

    method description->String
      return name

    method execute->Logical
      if (not global_statements.count)
        Program.execution_status = Program.EXE_RETURN
        Program.execution_result = BossValue()
        return true
      endIf

      #local statements = global_statements
      #global_statements = Statements(t)

      #{
      local r_launch = Routine( t, "global_statements", global_statements )
      MethodOrganizer( this ).visit( null, r_launch )
      Resolver( this ).visit( null, r_launch )
      if (Program.execute( r_launch, null )) return true
      return false
      }#
      trace "TODO"
      return true

    method find_type( name:String, &extended_search )->Type
      if (is_visiting) return null

      local result = types[ name ]
      if (result) return result

      temporarily is_visiting = true
        forEach (used_m in used_modules)
          if (extended_search or used_m.is_exported)
            result = used_m.m.find_type( name, &!extended_search )
            if (result) escapeForEach
          endIf
        endForEach
      endTemporarily

      return result

    method must_find_type( t:Token, name:String )->Type
      local result = find_type( name )
      if (result) return result
      throw t.error( "No such type '$'." (name) )

      #{
    method organize_types
      if (is_resolving) return
      if (state >= STATE_TYPES_ORGANIZED) return
      state = STATE_TYPES_ORGANIZED

      temporarily is_resolving = true
        local type_organizer = TypeOrganizer( this )
        type_organizer.visit( forEach in types )
      endTemporarily

    method organize_methods
      if (is_resolving) return
      if (state >= STATE_METHODS_ORGANIZED) return
      organize_types
      state = STATE_METHODS_ORGANIZED

      temporarily is_resolving = true
        local method_organizer = MethodOrganizer( this )
        forEach (r in (forEach in routines_by_name))
          method_organizer.visit( null, r )
        endForEach
        method_organizer.visit( forEach in types )
      endTemporarily

    method resolve
      if (is_resolving) return
      if (state >= STATE_RESOLVED) return
      organize_methods
      state = STATE_RESOLVED

      temporarily is_resolving = true
        local resolver = Resolver( this )
        forEach (r in (forEach in routines_by_name))
          resolver.visit( null, r )
        endForEach
        resolver.visit( forEach in types )
      endTemporarily
      }#

    method organize
      if (is_organized) return
      is_organized = true
      local organizer = Organizer( this )
      organizer.visit( forEach in types )
      #forEach (r in (forEach in routines_by_name))
      #    method_organizer.visit( null, r )
      #  endForEach
      #method_organizer.visit( forEach in types )

    method resolve
      if (is_resolved) return
      is_resolved = true
      organize

    method uses_module( m:Module, &is_exported )
      if (m is this) return # happens when this is the default module
      forEach (existing_m in used_modules)
        if (existing_m.m is m) return
      endForEach
      used_modules.add( UsedModule(m,&=is_exported) )

endClass

class UsedModule( m:Module, is_exported:Logical ) [compound]
endClass

