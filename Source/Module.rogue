module Boss

class Module
  PROPERTIES
    t    : Token
    name : String

    used_modules      = UsedModule[]
    types             = StringTable<<Type>>()
    global_statements : Statements
    routines          = Procedures()

    is_visiting : Logical

  METHODS
    method init( t, name )
      global_statements = Statements(t)
      Program.all_modules.add( this )
      Program.modules_by_name[ name ] = this

    method collect_routines( m_name:String, list:Procedure[], &is_limited )
      if (is_visiting) return

      local matching = routines.by_name[ m_name ]
      if (matching) list.add( matching )

      is_visiting = true
      forEach (used_m in used_modules)
        if (not is_limited or used_m.is_exported)
          used_m.m.collect_routines( m_name, list, &=is_limited )
        endIf
      endForEach
      is_visiting = false

    method description->String
      return name

    method find_type( name:String, &is_limited )->Type
      if (is_visiting) return null

      local result = types[ name ]
      if (result) return result

      is_visiting = true
      forEach (used_m in used_modules)
        if (not is_limited or used_m.is_exported)
          result = used_m.m.find_type( name, &is_limited )
          if (result) escapeForEach
        endIf
      endForEach
      is_visiting = false

      return result

    method launch
      if (global_statements.count)
        local statements = global_statements
        global_statements = Statements(t)

        local r_launch = Routine( t, "global_statements", null, null, null, statements )
        MethodOrganizer(this,r_launch).visit( r_launch )
        Resolver(this,null,r_launch).visit( r_launch )
        Program.execute( r_launch, null )
      endIf

    method must_find_type( t:Token, name:String )->Type
      local result = find_type( name )
      if (result) return result
      throw t.error( "No such type '$'." (name) )

    method organize_types
      # TODO: arrange class inheritance

    method organize_methods
      forEach (r in (forEach in routines.by_name))
        MethodOrganizer(this,r).visit( r )
      endForEach
      MethodOrganizer(this,null).visit( global_statements )

    method resolve
      forEach (r in (forEach in routines.by_name))
        Resolver(this,null,r).visit( r )
      endForEach
      Resolver(this,null,null).visit( global_statements )

    method use_module( m:Module, &is_exported )
      if (m is this) return # happens when this is the default module
      forEach (existing_m in used_modules)
        if (existing_m.m is m) return
      endForEach
      used_modules.add( UsedModule(m,&=is_exported) )

endClass

class UsedModule( m:Module, is_exported:Logical ) [compound]
endClass

