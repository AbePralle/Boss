module Boss

# execute()
augment
  METHODS
    method Cmd.execute->Logical
      throw t.error( "[INTERNAL] $.execute() is undefined."(type_name) )

    method CmdList.execute->Logical
      forEach (cmd in list)
        if (not cmd.execute) return false
      endForEach
      return true

    method AddInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result.x->Int32
      return true

    method AddReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result.x
      return true

    method AddValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result
      return true

    method CallRoutine.execute->Logical
      temporarily Program.fp = Program.stack.count
        if (args)
          forEach (arg in args)
            if (not arg.execute) return false
            Program.stack.add( Program.execution_result )
          endForEach
        endIf
        Program.stack.expand( procedure.local_stack_slots )

        local status = procedure.statements.execute
        Program.stack.count = Program.fp
        if (status) return true
        if (Program.execution_status != Program.EXE_RETURN) return false
        Program.execution_status = Program.EXE_CONTINUE
        return true
      endTemporarily

    method CastInt32ToReal64.execute->Logical
      if (not operand.execute) return false
      # Program.execution_result is already correct
      return true

    method CastToValue.execute->Logical
      if (not operand.execute) return false
      return true

    method CastStringToReal64.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.object->(as String)->Real64
      return true

    method DescriptionInt32.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.x->Int32->String
      return true

    method DescriptionReal64.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.x->String
      return true

    method DescriptionValue.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.description
      return true

    method GetLocalValue.execute->Logical
      Program.execution_result = Program.stack[ Program.fp + index ]
      return true

    method LiteralString.execute->Logical
      Program.execution_result = value
      return true

    method LiteralLogical.execute->Logical
      Program.execution_result = value
      return true

    method LiteralCharacter.execute->Logical
      Program.execution_result = value
      return true

    method LiteralInt32.execute->Logical
      Program.execution_result = value
      return true

    method LiteralReal64.execute->Logical
      Program.execution_result = value
      return true

    method LiteralPi.execute->Logical
      Program.execution_result = pi
      return true

    method Print.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      return true

    method Println.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      println
      return true

    method PushResult.execute->Logical
      if (not operand.execute) return false
      Program.stack.add( Program.execution_result )
      return true

    method Return.execute->Logical
      Program.execution_status = Program.EXE_RETURN
      return false

    method ReturnResult.execute->Logical
      if (not result.execute) return false
      Program.execution_status = Program.EXE_RETURN
      return false

    method SubtractInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result = a - Program.execution_result.x->Int32
      return true

    method SubtractReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a - Program.execution_result.x
      return true
endAugment
