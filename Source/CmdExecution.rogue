module Boss

# execute()
augment
  METHODS
    method Cmd.execute->Logical
      throw t.error( "[INTERNAL] $.execute() is undefined."(type_name) )

    method CmdList.execute->Logical
      forEach (cmd in list)
        if (not cmd.execute) return false
      endForEach
      return true

    method AddAndAssignLocalInt32.execute->Logical
      if (not operand.execute) return false
      local index = Program.fp + info.fp_offset
      Program.stack[index].x = Program.stack[index].x->Int32 + Program.execution_result.x->Int32
      return true

    method AddAndAssignPropertyInt32.execute->Logical
      if (not context.execute) return false
      local properties = Program.execution_result.object->(as BossObject).properties
      if (not operand.execute) return false
      local index = info.index
      properties[index].x = properties[index].x->Int32 + Program.execution_result.x->Int32
      return true

    method AddAndAssignThisPropertyInt32.execute->Logical
      if (not operand.execute) return false
      local properties = Program.stack[ Program.fp ].object->(as BossObject).properties
      local index = info.index
      properties[index].x = properties[index].x->Int32 + Program.execution_result.x->Int32
      return true

    method AddInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result.x = a + Program.execution_result.x->Int32
      return true

    method AddReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result.x = a + Program.execution_result.x
      return true

    method AddValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result
      return true

    method BitwiseAndInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result.x = a & Program.execution_result.x->Int32
      return true

    method BitwiseAndValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a & Program.execution_result
      return true

    method BitwiseOrAndAssignLocalInt32.execute->Logical
      if (not operand.execute) return false
      local index = Program.fp + info.fp_offset
      Program.stack[index].x = Program.stack[index].x->Int32 | Program.execution_result.x->Int32
      return true

    method BitwiseOrAndAssignPropertyInt32.execute->Logical
      if (not context.execute) return false
      local properties = Program.execution_result.object->(as BossObject).properties
      if (not operand.execute) return false
      local index = info.index
      properties[index].x = properties[index].x->Int32 | Program.execution_result.x->Int32
      return true

    method BitwiseOrAndAssignThisPropertyInt32.execute->Logical
      if (not operand.execute) return false
      local properties = Program.stack[ Program.fp ].object->(as BossObject).properties
      local index = info.index
      properties[index].x = properties[index].x->Int32 | Program.execution_result.x->Int32
      return true

    method BitwiseOrInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result.x = a | Program.execution_result.x->Int32
      return true

    method BitwiseOrValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a | Program.execution_result
      return true

    method BitwiseXorInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result.x = a ~ Program.execution_result.x->Int32
      return true

    method BitwiseXorValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a ~ Program.execution_result
      return true

    method Block.execute->Logical
      return statements.execute

    method CallGlobalMethod.execute->Logical
      return Program.execute( procedure, args )

    method CallMethod.execute->Logical
      assert context
      if (not context.execute) return false
      return Program.execute( Program.execution_result, procedure, args )

    method CallNative.execute->Logical
      Program.execution_result = handler()
      return Program.execution_status == Program.EXE_CONTINUE

    method CallThisMethod.execute->Logical
      assert Program.stack[Program.fp].object
      return Program.execute( Program.stack[Program.fp].object->(as BossObject), procedure, args )

    method CallRoutine.execute->Logical
      return Program.execute( procedure, args )

    method CastInt32ToReal64.execute->Logical
      if (not operand.execute) return false
      # Program.execution_result is already correct
      return true

    method CastReal64ToInt32.execute->Logical
      if (not operand.execute) return false
      Program.execution_result.x = Program.execution_result.x->Int32
      return true

    method CastToValue.execute->Logical
      if (not operand.execute) return false
      return true

    method CastStringToReal64.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.object->(as String)->Real64
      return true

    method CastValueToInt32.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result->Int32
      return true

    method CastValueToReal64.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result->Real64
      return true

    method CastValueToXY.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result->XY
      return true

    method CompareEQReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a == Program.execution_result.x)
      return true

    method CompareNEReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a != Program.execution_result.x)
      return true

    method CompareLTReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a < Program.execution_result.x)
      return true

    method CompareGTReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a > Program.execution_result.x)
      return true

    method CompareLEReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a <= Program.execution_result.x)
      return true

    method CompareGEReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a >= Program.execution_result.x)
      return true

    method CreateObject.execute->Logical
      local obj = of_type.create_object
      if (m_init)
        if (not Program.execute( obj, m_init, args )) return false
      endIf
      Program.execution_result = obj
      return true

    method CreateXY0.execute->Logical
      Program.execution_result = XY.zero
      return true

    method CreateXY1.execute->Logical
      if (not value.execute) return false
      local n = Program.execution_result.x
      Program.execution_result = XY(n,n)
      return true

    method CreateXY2.execute->Logical
      if (not x.execute) return false
      local x = Program.execution_result.x
      if (not y.execute) return false
      local y = Program.execution_result.x
      Program.execution_result = XY(x,y)
      return true

    method DecrementLocalInt32.execute->Logical
      local index = Program.fp + info.fp_offset
      Program.stack[index].x = Program.stack[index].x->Int32 - 1
      return true

    method DecrementThisPropertyInt32.execute->Logical
      local properties = Program.stack[ Program.fp ].object->(as BossObject).properties
      local index = info.index
      properties[index].x = properties[index].x->Int32 - 1
      return true

    method Description.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.description
      return true

    method DivideInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      local b = Program.execution_result.x->Int32
      if (b == 0) return Program.error( t, "Illegal integer division by zero." )
      Program.execution_result = a / b
      return true

    method DivideReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result.x = a / Program.execution_result.x
      return true

    method DivideString.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result->String

      if (not right.execute) return false
      Program.execution_result = a / Program.execution_result->String
      return true

    method DivideValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a / Program.execution_result
      return true

    method EmptyList.execute->Logical
      Program.execution_result = BossValue.list
      return true

    method ForEachInIndexedCollection.execute->Logical
      local fp = Program.fp

      if (not collection_v.initial_value.execute) return false
      local collection = Program.execution_result
      local collection_fp = fp + collection_v.fp_offset
      Program.stack[ collection_fp ] = collection

      if (not index_v.initial_value.execute) return false
      local index = Program.execution_result.x->Int32
      local index_fp = fp + index_v.fp_offset

      local control_fp = fp + control_v.fp_offset

      if (not cmd_count.execute) return false
      local count = Program.execution_result.x->Int32

      loop (count - index)
        Program.stack[ index_fp ] = index
        if (not cmd_get.execute) return false
        Program.stack[ control_fp ] = Program.execution_result
        if (not statements.execute) return false
        ++index
      endLoop

      return true

    method GetLocal.execute->Logical
      Program.execution_result = Program.stack[ Program.fp + fp_offset ]
      return true

    method GetProperty.execute->Logical
      if (not context.execute) return false
      Program.execution_result = Program.execution_result.object->(as BossObject).properties[index]
      return true

    method GetSingleton.execute->Logical
      local obj = type.singleton_object
      if (not obj) return false
      Program.execution_result = obj
      return true

    method GetThisProperty.execute->Logical
      assert Program.fp < Program.stack.count
      Program.execution_result = Program.stack[Program.fp].object->(as BossObject).properties[index]
      return true

    method If.execute->Logical
      if (condition)
        # 'If' is also used for 'else'; elses have no condition.
        if (not condition.execute) return false
        if (Program.execution_result)
          return statements.execute
        else
          if (cmd_else) return cmd_else.execute
          return true
        endIf
      else
        return statements.execute
      endIf

    method ImportModule.execute->Logical
      return Program.import( t, filepath )

    method IncrementLocalInt32.execute->Logical
      local index = Program.fp + info.fp_offset
      Program.stack[index].x = Program.stack[index].x->Int32 + 1
      return true

    method IncrementThisPropertyInt32.execute->Logical
      local properties = Program.stack[ Program.fp ].object->(as BossObject).properties
      local index = info.index
      properties[index].x = properties[index].x->Int32 + 1
      return true

    method LeftShiftInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      local b = Program.execution_result.x->Int32
      Program.execution_result = a :<<: b
      return true

    method LeftShiftValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a :<<: Program.execution_result
      return true

    method LiteralString.execute->Logical
      Program.execution_result = value
      return true

    method LiteralLogical.execute->Logical
      Program.execution_result = value
      return true

    method LiteralCharacter.execute->Logical
      Program.execution_result = value
      return true

    method LiteralInt32.execute->Logical
      Program.execution_result = value
      return true

    method LiteralReal64.execute->Logical
      Program.execution_result = value
      return true

    method LiteralPi.execute->Logical
      Program.execution_result = pi
      return true

    method LiteralValueList.execute->Logical
      local result = BossValue[]( args.count )
      forEach (arg in args)
        if (not arg.execute) return false
        result.add( Program.execution_result )
      endForEach
      Program.execution_result = BossValue.list(result)
      return true

    method LocalDeclaration.execute->Logical
      # Local declaration
      assert info.initial_value
      if (not info.initial_value.execute) return false
      assert info.fp_offset >= 0
      Program.stack[ Program.fp + info.fp_offset ] = Program.execution_result
      return true

      Program.execution_result = pi
      return true

    method LogicalAnd.execute->Logical
      if (not left.execute) return false
      if (not Program.execution_result) return true # result is already 'false'

      if (not right.execute) return false
      Program.execution_result = Program.execution_result?
      return true

    method LogicalOr.execute->Logical
      if (not left.execute) return false
      if (Program.execution_result?)
        Program.execution_result = true
        return true
      endIf

      if (not right.execute) return false
      Program.execution_result = Program.execution_result?
      return true

    method LogicalXor.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result?

      if (not right.execute) return false
      local b = Program.execution_result?
      Program.execution_result = a xor b
      return true

    method Loop.execute->Logical
      if (loop_count)
        if (not loop_count.execute) return false
        local n = Program.execution_result.x->Int32
        while (n > 0)
          --n
          if (not statements.execute) return false
        endWhile
        return true
      else
        while (statements.execute) noAction
        return false
      endIf

    method ModInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      local b = Program.execution_result.x->Int32
      if (b == 0) return Program.error( t, "Illegal integer modulo zero." )
      Program.execution_result = a % b
      return true

    method ModReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result.x = a % Program.execution_result.x
      return true

    method ModValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a % Program.execution_result
      return true

    method MultiplyInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result.x = a * Program.execution_result.x->Int32
      return true

    method MultiplyReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result.x = a * Program.execution_result.x
      return true

    method MultiplyValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a * Program.execution_result
      return true

    method NegateInt32.execute->Logical
      if (not operand.execute) return false
      Program.execution_result.x = -Program.execution_result.x->Int32
      return true

    method NegateReal64.execute->Logical
      if (not operand.execute) return false
      Program.execution_result.x = -Program.execution_result.x
      return true

    method NegateValue.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = -Program.execution_result
      return true

    method Print.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      return true

    method Println.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      println
      return true

    method PushResult.execute->Logical
      if (not operand.execute) return false
      Program.stack.add( Program.execution_result )
      return true

    method Return.execute->Logical
      Program.execution_status = Program.EXE_RETURN
      return false

    method ReturnResult.execute->Logical
      if (not result.execute) return false
      Program.execution_status = Program.EXE_RETURN
      return false

    method RightShiftInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      local b = Program.execution_result.x->Int32
      Program.execution_result = a :>>: b
      return true

    method RightShiftValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a :>>: Program.execution_result
      return true

    method RightShiftXInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      local b = Program.execution_result.x->Int32
      Program.execution_result = a :>>>: b
      return true

    method RightShiftXValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a :>>>: Program.execution_result
      return true

    method SetLocal.execute->Logical
      if (not new_value.execute) return false
      Program.stack[ Program.fp + info.fp_offset ] = Program.execution_result
      return true

    method SetThisProperty.execute->Logical
      if (not new_value.execute) return false
      Program.stack[Program.fp].object->(as BossObject).properties[index] = Program.execution_result
      return true

    method StackTopInt32.execute->Logical
      noAction  # stack is already correct
      return true

    method SubtractInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result.x = a - Program.execution_result.x->Int32
      return true

    method SubtractReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result.x = a - Program.execution_result.x
      return true

    method ValueAsInt32.execute->Logical
      if (not operand.execute) return false
      return true

    method While.execute->Logical
      if (not condition.execute) return false
      while (Program.execution_result.x)
        if (not statements.execute)
          # TODO: check for escape / continue
          return false
        endIf
        if (not condition.execute) return false
      endWhile
      return true

    method XYGetX.execute->Logical
      if (not context.execute) return false
      # Program.execution_result is already correct
      return true

    method XYGetY.execute->Logical
      if (not context.execute) return false
      Program.execution_result.x = Program.execution_result.y
      return true
endAugment

