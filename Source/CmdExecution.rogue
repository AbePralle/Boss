module Boss

# execute()
augment
  METHODS
    method Cmd.execute->Logical
      throw t.error( "[INTERNAL] $.execute() is undefined."(type_name) )

    method CmdList.execute->Logical
      forEach (cmd in list)
        if (not cmd.execute) return false
      endForEach
      return true

    method AddInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result.x->Int32
      return true

    method AddReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result.x
      return true

    method CallRoutine.execute->Logical
      if (args)
        temporarily Program.fp = Program.stack.count
          forEach (arg in args)
            if (not arg.execute) return false
          endForEach
          if (not procedure.statements.execute) return false
          Program.stack.count = Program.fp
        endTemporarily

      else
        if (not procedure.statements.execute) return false
        return true

      endIf
      return true

    method CastInt32ToReal64.execute->Logical
      if (not operand.execute) return false
      # Program.execution_result is already correct
      return true

    method CastToValue.execute->Logical
      if (not operand.execute) return false
      return true

    method CastStringToReal64.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.object->(as String)->Real64
      return true

    method DescriptionInt32.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.x->Int32->String
      return true

    method DescriptionReal64.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.x->String
      return true

    method DescriptionValue.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.description
      return true

    method GetLocalValue.execute->Logical
      Program.execution_result = Program.stack[ Program.fp + index ]
      return true

    method LiteralString.execute->Logical
      Program.execution_result = value
      return true

    method LiteralLogical.execute->Logical
      Program.execution_result = value
      return true

    method LiteralCharacter.execute->Logical
      Program.execution_result = value
      return true

    method LiteralInt32.execute->Logical
      Program.execution_result = value
      return true

    method LiteralReal64.execute->Logical
      Program.execution_result = value
      return true

    method LiteralPi.execute->Logical
      Program.execution_result = pi
      return true

    method Print.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      return true

    method Println.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      println
      return true

    method PushResult.execute->Logical
      if (not operand.execute) return false
      Program.stack.add( Program.execution_result )
      return true

    method SubtractInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result = a - Program.execution_result.x->Int32
      return true

    method SubtractReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a - Program.execution_result.x
      return true
endAugment
