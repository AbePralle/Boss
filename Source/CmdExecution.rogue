module Boss

# execute()
augment
  METHODS
    method Cmd.execute->Logical
      throw t.error( "[INTERNAL] $.execute() is undefined."(type_name) )

    method CmdList.execute->Logical
      forEach (cmd in list)
        if (not cmd.execute) return false
      endForEach
      return true

    method AddAndAssignLocalInt32.execute->Logical
      if (not operand.execute) return false
      local index = Program.fp + info.fp_offset
      Program.stack[index].x = Program.stack[index].x->Int32 + Program.execution_result.x->Int32
      return true

    method AddAndAssignPropertyInt32.execute->Logical
      if (not context.execute) return false
      local properties = Program.execution_result.object->(as BossObject).properties
      if (not operand.execute) return false
      local index = info.index
      properties[index].x = properties[index].x->Int32 + Program.execution_result.x->Int32
      return true

    method AddAndAssignThisPropertyInt32.execute->Logical
      if (not operand.execute) return false
      local properties = Program.stack[ Program.fp ].object->(as BossObject).properties
      local index = info.index
      properties[index].x = properties[index].x->Int32 + Program.execution_result.x->Int32
      return true

    method AddInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result.x->Int32
      return true

    method AddReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result.x
      return true

    method AddValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result
      return true

    method CallGlobalMethod.execute->Logical
      return Program.execute( procedure, args )

    method CallMethod.execute->Logical
      assert context
      if (not context.execute) return false
      return Program.execute( Program.execution_result, procedure, args )

    method CallNative.execute->Logical
      Program.execution_result = handler()
      return Program.execution_status == Program.EXE_CONTINUE

    method CallThisMethod.execute->Logical
      assert Program.stack[Program.fp].object
      return Program.execute( Program.stack[Program.fp].object->(as BossObject), procedure, args )

    method CallRoutine.execute->Logical
      return Program.execute( procedure, args )

    method CastInt32ToReal64.execute->Logical
      if (not operand.execute) return false
      # Program.execution_result is already correct
      return true

    method CastToValue.execute->Logical
      if (not operand.execute) return false
      return true

    method CastStringToReal64.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.object->(as String)->Real64
      return true

    method CompareEQReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a == Program.execution_result.x)
      return true

    method CompareNEReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a != Program.execution_result.x)
      return true

    method CompareLTReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a < Program.execution_result.x)
      return true

    method CompareGTReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a > Program.execution_result.x)
      return true

    method CompareLEReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a <= Program.execution_result.x)
      return true

    method CompareGEReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x
      if (not right.execute) return false
      Program.execution_result.x = (a >= Program.execution_result.x)
      return true

    method CreateObject.execute->Logical
      local obj = of_type.create_object
      if (m_init)
        if (not Program.execute( obj, m_init, args )) return false
      endIf
      Program.execution_result = obj
      return true

    method Description.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.description
      return true

    method DivideInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      local b = Program.execution_result.x->Int32
      if (b == 0) return Program.error( t, "Illegal integer division by zero." )
      Program.execution_result = a / b
      return true

    method DivideReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a / Program.execution_result.x
      return true

    method DivideString.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result->String

      if (not right.execute) return false
      Program.execution_result = a / Program.execution_result->String
      return true

    method DivideValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a / Program.execution_result
      return true

    method EmptyList.execute->Logical
      Program.execution_result = BossValue.list
      return true

    method GetLocal.execute->Logical
      Program.execution_result = Program.stack[ Program.fp + fp_offset ]
      return true

    method GetProperty.execute->Logical
      if (not context.execute) return false
      Program.execution_result = Program.execution_result.object->(as BossObject).properties[index]
      return true

    method GetSingleton.execute->Logical
      local obj = type.singleton_object
      if (not obj) return false
      Program.execution_result = obj
      return true

    method GetThisProperty.execute->Logical
      assert Program.fp < Program.stack.count
      Program.execution_result = Program.stack[Program.fp].object->(as BossObject).properties[index]
      return true

    method If.execute->Logical
      if (condition)
        # 'If' is also used for 'else'; elses have no condition.
        if (not condition.execute) return false
        if (Program.execution_result)
          return statements.execute
        else
          if (cmd_else) return cmd_else.execute
          return true
        endIf
      else
        return statements.execute
      endIf

    method ImportModule.execute->Logical
      return Program.import( t, filepath )

    method IncrementLocalInt32.execute->Logical
      local index = Program.fp + info.fp_offset
      Program.stack[index].x = Program.stack[index].x->Int32 + 1
      return true

    method IncrementThisPropertyInt32.execute->Logical
      local properties = Program.stack[ Program.fp ].object->(as BossObject).properties
      local index = info.index
      properties[index].x = properties[index].x->Int32 + 1
      return true

    method LiteralString.execute->Logical
      Program.execution_result = value
      return true

    method LiteralLogical.execute->Logical
      Program.execution_result = value
      return true

    method LiteralCharacter.execute->Logical
      Program.execution_result = value
      return true

    method LiteralInt32.execute->Logical
      Program.execution_result = value
      return true

    method LiteralReal64.execute->Logical
      Program.execution_result = value
      return true

    method LiteralPi.execute->Logical
      Program.execution_result = pi
      return true

    method LocalDeclaration.execute->Logical
      # Local declaration
      assert info.initial_value
      if (not info.initial_value.execute) return false
      assert info.fp_offset >= 0
      Program.stack[ Program.fp + info.fp_offset ] = Program.execution_result
      return true

      Program.execution_result = pi
      return true

    method LogicalAnd.execute->Logical
      if (not left.execute) return false
      if (not Program.execution_result) return true # result is already 'false'

      if (not right.execute) return false
      Program.execution_result = Program.execution_result?
      return true

    method LogicalOr.execute->Logical
      if (not left.execute) return false
      if (Program.execution_result?)
        Program.execution_result = true
        return true
      endIf

      if (not right.execute) return false
      Program.execution_result = Program.execution_result?
      return true

    method LogicalXor.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result?

      if (not right.execute) return false
      local b = Program.execution_result?
      Program.execution_result = a xor b
      return true

    method ModInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      local b = Program.execution_result.x->Int32
      if (b == 0) return Program.error( t, "Illegal integer modulo zero." )
      Program.execution_result = a % b
      return true

    method ModReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a % Program.execution_result.x
      return true

    method ModValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a % Program.execution_result
      return true

    method MultiplyInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result = a * Program.execution_result.x->Int32
      return true

    method MultiplyReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a * Program.execution_result.x
      return true

    method MultiplyValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a * Program.execution_result
      return true

    method Print.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      return true

    method Println.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      println
      return true

    method PushResult.execute->Logical
      if (not operand.execute) return false
      Program.stack.add( Program.execution_result )
      return true

    method Return.execute->Logical
      Program.execution_status = Program.EXE_RETURN
      return false

    method ReturnResult.execute->Logical
      if (not result.execute) return false
      Program.execution_status = Program.EXE_RETURN
      return false

    method SetThisProperty.execute->Logical
      if (not new_value.execute) return false
      Program.stack[Program.fp].object->(as BossObject).properties[index] = Program.execution_result
      return true

    method SubtractInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result = a - Program.execution_result.x->Int32
      return true

    method SubtractReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a - Program.execution_result.x
      return true

    method While.execute->Logical
      if (not condition.execute) return false
      while (Program.execution_result.x)
        if (not statements.execute)
          # TODO: check for escape / continue
          return false
        endIf
        if (not condition.execute) return false
      endWhile
      return true
endAugment
