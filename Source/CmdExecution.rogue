module Boss

# execute()
augment
  METHODS
    method Cmd.execute->Logical
      throw t.error( "[INTERNAL] $.execute() is undefined."(type_name) )

    method CmdList.execute->Logical
      forEach (cmd in list)
        if (not cmd.execute) return false
      endForEach
      return true

    method AddInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result.x->Int32
      return true

    method AddReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result.x
      return true

    method AddValue.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result

      if (not right.execute) return false
      Program.execution_result = a + Program.execution_result
      return true

    method CallRoutine.execute->Logical
      return Program.execute( procedure, args )

    method CastInt32ToReal64.execute->Logical
      if (not operand.execute) return false
      # Program.execution_result is already correct
      return true

    method CastToValue.execute->Logical
      if (not operand.execute) return false
      return true

    method CastStringToReal64.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.object->(as String)->Real64
      return true

    method CreateObject.execute->Logical
      Program.execution_result = BossObject( @type )
      return true

    method Description.execute->Logical
      if (not operand.execute) return false
      Program.execution_result = Program.execution_result.description
      return true

    method GetLocal.execute->Logical
      Program.execution_result = Program.stack[ Program.fp + fp_offset ]
      return true

    method ImportModule.execute->Logical
      return Program.import( t, filepath )

    method LiteralString.execute->Logical
      Program.execution_result = value
      return true

    method LiteralLogical.execute->Logical
      Program.execution_result = value
      return true

    method LiteralCharacter.execute->Logical
      Program.execution_result = value
      return true

    method LiteralInt32.execute->Logical
      Program.execution_result = value
      return true

    method LiteralReal64.execute->Logical
      Program.execution_result = value
      return true

    method LiteralPi.execute->Logical
      Program.execution_result = pi
      return true

    method Local.execute->Logical
      # Local declaration
      assert initial_value
      if (not initial_value.execute) return false
      Program.stack[ Program.fp + fp_offset ] = Program.execution_result
      return true

      Program.execution_result = pi
      return true

    method Print.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      return true

    method Println.execute->Logical
      forEach (cmd in args.list)
        if (not cmd.execute) return false
        print Program.execution_result
      endForEach
      println
      return true

    method PushResult.execute->Logical
      if (not operand.execute) return false
      Program.stack.add( Program.execution_result )
      return true

    method Return.execute->Logical
      Program.execution_status = Program.EXE_RETURN
      return false

    method ReturnResult.execute->Logical
      if (not result.execute) return false
      Program.execution_status = Program.EXE_RETURN
      return false

    method SubtractInt32.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x->Int32

      if (not right.execute) return false
      Program.execution_result = a - Program.execution_result.x->Int32
      return true

    method SubtractReal64.execute->Logical
      if (not left.execute) return false
      local a = Program.execution_result.x

      if (not right.execute) return false
      Program.execution_result = a - Program.execution_result.x
      return true
endAugment
