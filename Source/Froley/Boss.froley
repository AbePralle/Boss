#---------------------------------------------------------------------
[settings]
#---------------------------------------------------------------------
id_start    alpha '_'
id_continue alpha numeric '_'

#---------------------------------------------------------------------
[whitespace]
#---------------------------------------------------------------------
SPACE ' '
TAB   '\t'
CR    '\r'

#---------------------------------------------------------------------
[attributes]
#---------------------------------------------------------------------
structural

#---------------------------------------------------------------------
[tokens]
#---------------------------------------------------------------------
EOL            "\n"
BINARY_INTEGER integer      [content]
OCTAL_INTEGER  integer      [content]
HEX_INTEGER    integer      [content]
INTEGER        integer      [content]
REAL_NUMBER    real         [content]
STRING         string       [content]
IDENTIFIER     identifier   [content]


#---------------------------------------------------------------------
[keywords]
#---------------------------------------------------------------------
KEYWORD_AUGMENT      augment
KEYWORD_CLASS        class       [structural]
KEYWORD_MODULE       module
KEYWORD_ELSE         else        [structural]
KEYWORD_ELSE_IF      elseIf
KEYWORD_END_CLASS    endClass    [structural]
KEYWORD_END_FOR_EACH endForEach  [structural]
KEYWORD_END_IF       endIf       [structural]
KEYWORD_END_ROUTINE  endRoutine  [structural]
KEYWORD_END_WHILE    endWhile    [structural]
KEYWORD_FALSE        false
KEYWORD_FOR_EACH     forEach
KEYWORD_GLOBAL       global
KEYWORD_GLOBAL_PROPERTIES "GLOBAL PROPERTIES" [structural]
KEYWORD_GLOBAL_METHODS    "GLOBAL METHODS"    [structural]
KEYWORD_IF           if
KEYWORD_IN           in
KEYWORD_IMPORT       import
KEYWORD_LOCAL        local
KEYWORD_METHOD       method
KEYWORD_METHODS      METHODS     [structural]
KEYWORD_NO_ACTION    noAction
KEYWORD_NULL         null
KEYWORD_OF           of
KEYWORD_PRINTLN      println
KEYWORD_PROPERTIES   PROPERTIES  [structural]
KEYWORD_RETURN       return
KEYWORD_ROUTINE      routine
KEYWORD_STEP         step
KEYWORD_THIS_CALL    thisCall
KEYWORD_TRUE         true
KEYWORD_UNDEFINED    undefined
KEYWORD_USES         uses
KEYWORD_WHILE        while

#---------------------------------------------------------------------
[symbols]
#---------------------------------------------------------------------
SYMBOL_AMPERSAND            &
SYMBOL_ARROW                ->
SYMBOL_ASTERISK             *
SYMBOL_AT                   @
SYMBOL_BANG                 !
SYMBOL_CARET                ^
SYMBOL_CLOSE_BRACE          }   [structural]
SYMBOL_CLOSE_BRACKET        ]   [structural]
SYMBOL_CLOSE_PAREN          )   [structural]
SYMBOL_COLON                :   [structural]
SYMBOL_COLON_COLON          ::
SYMBOL_COMMA                ,   [structural]
SYMBOL_DOLLAR               $
SYMBOL_DOUBLE_VERTICAL_BAR  ||  [structural]
SYMBOL_EQ                   ==
SYMBOL_EQUALS               =
SYMBOL_GE                   >=
SYMBOL_GT                   >
SYMBOL_GT_GT                >>
SYMBOL_LE                   <=
SYMBOL_LEFT_SHIFT           :<<:
SYMBOL_LITERAL_OPEN_BRACKET @[
SYMBOL_LT                   <
SYMBOL_LT_LT                <<
SYMBOL_MINUS                -
SYMBOL_MINUS_MINUS          --
SYMBOL_NE                   !=
SYMBOL_OPEN_BRACE           {
SYMBOL_OPEN_BRACKET         [
SYMBOL_OPEN_PAREN           (
SYMBOL_PERCENT              %
SYMBOL_PERIOD               .
SYMBOL_PLUS                 +
SYMBOL_PLUS_PLUS            ++
SYMBOL_QUESTION             ?
SYMBOL_QUESTION_COLON       ?:
SYMBOL_RIGHT_SHIFT          :>>:
SYMBOL_RIGHT_SHIFT_X        :>>>:
SYMBOL_SEMICOLON            ;
SYMBOL_SLASH                /
SYMBOL_TILDE                ~
SYMBOL_VERTICAL_BAR         |

SYMBOL_PLUS_EQUALS          +=
SYMBOL_MINUS_EQUALS         -=
SYMBOL_TIMES_EQUALS         *=
SYMBOL_DIVIDE_EQUALS        /=
SYMBOL_MOD_EQUALS           %=
SYMBOL_AND_EQUALS           &=
SYMBOL_OR_EQUALS            |=

#---------------------------------------------------------------------
[tokenizer]
#---------------------------------------------------------------------
<<tokenize>>
which (input)
  discardAny [whitespace]
endWhich

markSourcePosition
if (not hasAnother)
  create EOL
  halt
endIf

<tokenize_identifier>
if (scanIdentifier)
  which (buffer)
    case "GLOBAL"
      while (consume(' ')) noAction
      if (scanIdentifier)
        which (buffer)
          case "PROPERTIES": produce KEYWORD_GLOBAL_PROPERTIES
          case "METHODS":    produce KEYWORD_GLOBAL_METHODS
        endWhich
      endIf
      syntaxError "Expected 'GLOBAL PROPERTIES' or 'GLOBAL METHODS'."
    produceAny [keywords]
    others: produce IDENTIFIER
  endWhich
endIf

clear buffer
tokenize_decimal

<tokenize_numbers>
which (input)
  case "0b"
    count = 2
    clear buffer
    scan_integer
    produce BINARY_INTEGER
  case "0c"
    count = 8
    clear buffer
    scan_integer
    produce OCTAL_INTEGER
  case "0x"
    count = 16
    clear buffer
    scan_integer
    produce HEX_INTEGER
  others
    ch = peek
    if (ch is digit)
      count = 10
      scan_integer
      if (nextIs('.'))
        tokenize_decimal
      elseIf (nextIs('e') or nextIs('E'))
        tokenize_exponent
      else
        produce INTEGER
      endIf
    endIf
endWhich

<tokenize_symbols>
which (input)
  produceAny [symbols]
  case '\n': produce EOL
  case "#{": consume_comment_span; restart
  case '#'
    ch = read
    while (ch != '\n') ch = read
    discard
  case '"'
    goto tokenize_string
  case "'"
    goto tokenize_single_quote_string
  case "''"
    goto tokenize_two_quote_string
  case '\''
    clear buffer
    scan_character
    consume('\'')
    produce CHARACTER
  case "@|"
    tokenize_verbatim_string
endWhich

syntaxError

<scan_integer>
while (hasAnother)
  ch = peek
  if (ch is digit base count or ch == '_')
    ch = read
    if (ch != '_') collect ch
  else
    return
  endIf
endWhile
return

<tokenize_decimal>
ch = peek
if (ch != '.') return
ch = peek( 1 )
if (ch is not digit) return
ch = read
collect ch
ch = read
collect ch

# Real number starting from .
while (hasAnother)
  ch = peek
  if (ch is digit)
    ch = read
    collect ch
  elseIf (ch == 'e' or ch == 'E')
    tokenize_exponent
  else
    produce REAL_NUMBER
  endIf
endWhile
produce REAL_NUMBER

<tokenize_exponent>
ch = read  # 'e' or 'E'
collect ch
if (consume('-'))     collect '-'
elseIf (consume('+')) collect '+'
ch = peek
if (ch is not digit) syntaxError "Syntax error - at least one digit is expected after the exponent."
count = 10  # base 10
scan_integer
produce REAL_NUMBER

<tokenize_string>
clear buffer
while (hasAnother and not nextIs('"'))
  scan_character
endWhile
mustConsume '"'
produce STRING

<tokenize_single_quote_string>
clear buffer
while (hasAnother and not nextIs('\''))
  scan_character
endWhile
mustConsume '\''
produce STRING

<tokenize_two_quote_string>
clear buffer
while (hasAnother)
  if (nextIs('\''))
    ch = peek(1)
    if (ch == '\'')
      ch = read
      ch = read
      produce STRING
    endIf
  endIf
  scan_character
endWhile
syntaxError "Unterminated two-quote string - expected '', found end of input."

<scan_character>
ch = read
if (ch == '\n')
  syntaxError "Unterminated string - unexpected end of line."
endIf
if (ch == '\\')
  if (consume('b')) collect 8; return
  if (consume('e')) collect 27; return
  if (consume('f')) collect 12; return
  if (consume('n')) collect '\n'; return
  if (consume('r')) collect '\r'; return
  if (consume('t')) collect '\t'; return
  if (consume('v')) collect 11; return
  if (consume('0')) collect 0; return
  if (consume('/')) collect '/'; return
  if (consume('?')) collect '?'; return
  if (consume('\''))collect '\''; return
  if (consume('\\'))collect '\\'; return
  if (consume('"')) collect '"'; return
  if (consume('x'))
    if (ch = scanDigits 2 base 16) collect ch; return
    syntaxError "Expected 2-digit hex code after '\\x'."
  endIf
  if (consume('u'))
    if (ch = scanDigits 4 base 16) collect ch; return
    syntaxError "Expected 4-digit hex code after '\\u'."
  endIf
  if (consume('['))
    if (ch = scanDigits 1..6 base 16)
      mustConsume ']'
      collect ch
      return
    endIf
    syntaxError "Expected hex code with 1-6 digits after '\\['."
  endIf
  clear buffer
  collect "Invalid escape sequence '"
  collect '\\'
  collect ch
  collect "'. Supported: \\b \\e \\f \\n \\r \\t \\v \\0 \\? \\/ \\' \\\\ \\\" \\xHH \\uHHHH \\[H*]."
  syntaxError buffer
endIf
collect ch
return

<tokenize_verbatim_string>
clear buffer
while (hasAnother)
  if (consume('\n'))
    collect '\n'
    while (consume(' '))
    endWhile
    if (not consume('|')) produce STRING
  else
    ch = read
    collect ch
  endIf
endWhile
produce STRING

<consume_comment_span>
while (hasAnother)
  which (input)
    case "#{"
      consume_comment_span
    case "}#"
      return
    others
      ch = read  # discard
  endWhich
endWhile

#---------------------------------------------------------------------
[parser]
#---------------------------------------------------------------------
- element
  while (consume(EOL)) noAction
  if (not hasAnother) return

  on "class", class -> ClassDefinition( name, base_types, attributes, elements )
  on "module", module_name, EOL -> ModuleDeclaration(name )

  if (not nextHasAttribute(structural)) multi_line_statements; return
  syntaxError

- consume_eols
  while (consume(EOL)) noAction

- consume_end_commands
  while (consume(EOL) or consume(';')) noAction

- consume_semicolons
  while (consume(';')) noAction

- class
  type
  base_types
  class_attributes
  class_sections
  mustConsume "endClass"

- base_types
  beginList
  if (not consume(':')) produceList
  type
  while (consume(','))
    consume_eols
    type
  endWhile
  produceList

- class_attributes
  beginList
  if (not consume('[')) produceList
  type
  consume_eols
  while (not nextIs(']'))
    type
    consume_eols
  endWhile
  mustConsume ']'
  produceList

- class_sections
  beginList
  if (not consume(';'))
    while (not nextIs("endClass")) class_section
  endIf
  produceList

- class_section
  consume_eols
  on "GLOBAL PROPERTIES"
    consume_eols
    while (not nextHasAttribute(structural))
      global_properties
    endWhile
    return
  elseOn "GLOBAL METHODS"
    consume_eols
    while (nextIs("method"))
      global_method
      consume_eols
    endWhile
    return
  elseOn "PROPERTIES"
    consume_eols
    while (not nextHasAttribute(structural))
      properties
    endWhile
    return
  elseOn "METHODS"
    consume_eols
    while (nextIs("method"))
      method
      consume_eols
    endWhile
    return
  endOn
  if (not nextIs("endClass")) syntaxError

- forEach_loop
  on "forEach"
    var has_parens = consume( '(' )
    name
    forEach_optional_at
    if (consume("in"))
      forEach_collection_and_body
      produce ForEachIn(name,optional_at:At,collection:ForEachCollection,statements)
    elseIf (consume("of"))
      forEach_collection_and_body
      produce ForEachOf(name,optional_at:At,collection:ForEachCollection,statements)
    else
      syntaxError "Expected 'in' or 'of'."
    endIf
  endOn

- forEach_optional_at
  if (not consume(@"at")) produceNull
  name
  produce At(name)

- forEach_collection_and_body
  expression
  if (consume('=')) expression         # end of queue: var,  expression
  else              createNull; swap   # end of queue: null, expression

  if (consume(@"from")) expression
  else                  createNull

  if (consume("step")) expression
  else                 createNull

  create ForEachCollection(v,expression,from,step_size)

  if (has_parens) mustConsume ')'

  if (consume(EOL))
    multi_line_statements
    mustConsume "endForEach"
  else
    single_line_statements
  endIf

- global_method
  on "method", name, method_parameters, method_return_type, method_body ->
    GlobalMethod(name,parameters,return_type,statements:NodeList)

- if_statement
  on "if"
    expression
    if (consume(EOL))
      # Multi-line 'if'
      multi_line_statements
      if_statement_multi_line_elseIf_else
      mustConsume 'endIf'
    else
      # Single-line 'if'
      single_line_statements
      if_statement_single_line_elseIf_else
    endIf
    produce If(condition,statements:NodeList,else_node:If)
  endOn

- if_statement_multi_line_elseIf_else
  savePosition
  on 'elseIf'
    expression
    if (consume(EOL))
      # This elseIf is multi-line; good to keep going
      discardPosition
      multi_line_statements
      if_statement_multi_line_elseIf_else
      produce If(condition,statements:NodeList,else_node:If)
    else
      # This single-line elseIf is outside the scope of the 'if' we're currently parsing.
      restorePosition
      produceNull
    endIf
  elseOn 'else'
    if (consume(EOL))
      # This else is multi-line; good to keep going
      discardPosition
      createNull
      multi_line_statements
      createNull
      produce If(condition,statements:NodeList,else_node:If)
    else
      # This single-line else is outside the scope of the 'if' we're currently parsing.
      restorePosition
      produceNull
    endIf
  else
    produceNull
  endOn

- if_statement_single_line_elseIf_else
  savePosition
  on 'elseIf'
    expression
    if (consume(EOL))
      # This elseIf is multi-line and outside our scope
      restorePosition
      produceNull
    else
      # This elseIf is single line; keep going
      discardPosition
      single_line_statements
      if_statement_single_line_elseIf_else
      produce If(condition,statements:NodeList,else_node:If)
    endIf
  elseOn 'else'
    if (consume(EOL))
      # This else is multi-line and outside our scope
      restorePosition
      produceNull
    else
      # This else is single line; keep going
      discardPosition
      createNull
      single_line_statements
      createNull
      produce If(condition,statements:NodeList,else_node:If)
    endIf
  else
    produceNull
  endOn


- method
  on "method", name, method_parameters, method_return_type, method_body ->
    Method(name,parameters,return_type,statements:NodeList)

- method_parameters
  beginList
  if (not consume('(')) produceList
  method_parameter
  while (consume(',')) method_parameter
  mustConsume ')'
  produceList

- method_parameter
  consume_eols
  onPeek IDENTIFIER, name, optional_initial_value, optional_type -> Parameter(name,initial_value,type)
  on '&',            name, optional_initial_value, optional_type -> FlagParameter(name,initial_value,type)
  mustConsume IDENTIFIER  # thow an error

- method_return_type
  if (not consume('->')) produceNull
  type

- method_body
  multi_line_statements

- multi_line_statements
  beginList
  consume_end_commands
  while (hasAnother and not nextHasAttribute(structural))
    statement_allowing_control_structures
    consume_end_commands
  endWhile
  produceStatements

- name
  on IDENTIFIER -> Name( value=t.content:String )
  mustConsume IDENTIFIER  # previous line didn't match; throw an error

- module_name : BinaryParseRule
  on "::" -> Scope

+ module_segment
  identifier

- global_properties
  consume_eols
  onPeek IDENTIFIER, var_declarations, mustConsume(EOL) -> GlobalProperties( declarations, type )

- properties
  consume_eols
  onPeek IDENTIFIER, var_declarations, mustConsume(EOL) -> Properties( declarations, type )

- statement_allowing_control_structures
  onPeek "forEach", forEach_loop: return
  onPeek "if",      if_statement: return
  onPeek "while",   while_loop:   return
  on "global", var_declarations -> GlobalDeclarations( declarations, type )
  on "local",  var_declarations -> LocalDeclarations( declarations, type )
  statement

- statement

  expression
  on "=" , expression -> Assign(target,expression)
  on "+=", expression -> AddAndAssign(target,expression)
  on "-=", expression -> SubtractAndAssign(target,expression)
  on "*=", expression -> MultiplyAndAssign(target,expression)
  on "/=", expression -> DivideAndAssign(target,expression)
  on "%=", expression -> ModAndAssign(target,expression)
  on "&=", expression -> AndAndAssign(target,expression)
  on "|=", expression -> OrAndAssign(target,expression)

- type
  on IDENTIFIER -> Type( name=t.content:String )
  mustConsume IDENTIFIER

- optional_initial_value
  if (consume('=')) consume_eols; expression
  else              createNull

- optional_type
  if (consume(':')) type
  else              createNull

- single_line_statements
  beginList
  consume_semicolons
  while (hasAnother and not consume(EOL))
    statement
    consume_semicolons
  endWhile
  produceStatements


- var_declarations
  beginList
  consume_eols
  var_declaration
  while (consume(','))
    consume_eols
    var_declaration
  endWhile
  createList
  optional_type

- var_declaration
  on IDENTIFIER, optional_initial_value -> VarDeclaration( name=t.content:String, initial_value )
  mustConsume IDENTIFIER

- while_loop
  on "while"
    expression
    if (consume(EOL)) multi_line_statements; mustConsume "endWhile"
    else              single_line_statements
    produce While(condition,statements)
  endOn

- expression

+ logical_xor  : BinaryParseRule

+ logical_or   : BinaryParseRule

+ logical_and  : BinaryParseRule

+ comparison : BinaryParseRule
  on "==" -> CompareEQ
  on "!=" -> CompareNE
  on "<"  -> CompareLT
  on ">"  -> CompareGT
  on "<=" -> CompareLE
  on ">=" -> CompareGE

+ bitwise_xor : BinaryParseRule

+ bitwise_or  : BinaryParseRule

+ bitwise_and : BinaryParseRule

+ bitwise_shift : BinaryParseRule

+ add_subtract : BinaryParseRule
  on "+" -> Add
  on "-" -> Subtract

+ multiply_divide : BinaryParseRule
  on "*" -> Multiply
  on "/" -> Divide

+ pre_unary : PreUnaryParseRule
  on "-"  -> Negate
  on "++" -> PreIncrement
  on "--" -> PreDecrement

+ post_unary : PostUnaryParseRule
  on "++" -> PostIncrement
  on "--" -> PostDecrement

+ access : BinaryParseRule

+ term
  on IDENTIFIER -> Access( value=t.content:String )
  on INTEGER    -> LiteralInt32( value=t.content:Int32 )
  on "true"     -> True
  on "false"    -> False
  on '(', expression, ')': return
  on "noAction" -> NoAction
  syntaxError

