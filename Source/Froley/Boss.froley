#---------------------------------------------------------------------
[settings]
#---------------------------------------------------------------------
id_start    alpha '_'
id_continue alpha numeric '_'

#---------------------------------------------------------------------
[whitespace]
#---------------------------------------------------------------------
SPACE ' '
TAB   '\t'
CR    '\r'

#---------------------------------------------------------------------
[attributes]
#---------------------------------------------------------------------
structural

#---------------------------------------------------------------------
[tokens]
#---------------------------------------------------------------------
BINARY_INTEGER integer     [content]
OCTAL_INTEGER  integer     [content]
HEX_INTEGER    integer     [content]
INTEGER        integer     [content]
STRING         string      [content]
IDENTIFIER     identifier  [content]


#---------------------------------------------------------------------
[keywords]
#---------------------------------------------------------------------
KEYWORD_AUGMENT     augment
KEYWORD_CLASS       class
KEYWORD_ELSE        else
KEYWORD_ELSE_IF     elseIf
KEYWORD_END_CLASS   endClass
KEYWORD_END_IF      endIf
KEYWORD_END_ROUTINE endRoutine
KEYWORD_END_WHILE   endWhile
KEYWORD_FALSE       false
KEYWORD_GLOBAL      global
KEYWORD_IF          if
KEYWORD_IMPORT      import
KEYWORD_LOCAL       local
KEYWORD_METHOD      method
KEYWORD_METHODS     METHODS
KEYWORD_NULL        null
KEYWORD_PRINTLN     println
KEYWORD_PROPERTIES  PROPERTIES
KEYWORD_RETURN      return
KEYWORD_ROUTINE     routine
KEYWORD_THIS_CALL   thisCall
KEYWORD_TRUE        true
KEYWORD_UNDEFINED   undefined
KEYWORD_WHILE       while

#---------------------------------------------------------------------
[symbols]
#---------------------------------------------------------------------
SYMBOL_AMPERSAND            &
SYMBOL_ARROW                ->
SYMBOL_ASTERISK             *
SYMBOL_AT                   @
SYMBOL_BANG                 !
SYMBOL_CARET                ^
SYMBOL_CLOSE_BRACE          }   [structural]
SYMBOL_CLOSE_BRACKET        ]   [structural]
SYMBOL_CLOSE_PAREN          )   [structural]
SYMBOL_COLON                :   [structural]
SYMBOL_COLON_COLON          ::
SYMBOL_COMMA                ,   [structural]
SYMBOL_DOLLAR               $
SYMBOL_DOUBLE_VERTICAL_BAR  ||  [structural]
SYMBOL_EQ                   ==
SYMBOL_EQUALS               =
SYMBOL_GE                   >=
SYMBOL_GT                   >
SYMBOL_GT_GT                >>
SYMBOL_LE                   <=
SYMBOL_LEFT_SHIFT           :<<:
SYMBOL_LITERAL_OPEN_BRACKET @[
SYMBOL_LT                   <
SYMBOL_LT_LT                <<
SYMBOL_MINUS                -
SYMBOL_MINUS_MINUS          --
SYMBOL_NE                   !=
SYMBOL_OPEN_BRACE           {
SYMBOL_OPEN_BRACKET         [
SYMBOL_OPEN_PAREN           (
SYMBOL_PERCENT              %
SYMBOL_PERIOD               .
SYMBOL_PLUS                 +
SYMBOL_PLUS_PLUS            ++
SYMBOL_QUESTION             ?
SYMBOL_QUESTION_COLON       ?:
SYMBOL_RIGHT_SHIFT          :>>:
SYMBOL_RIGHT_SHIFT_X        :>>>:
SYMBOL_SEMICOLON            ;
SYMBOL_SLASH                /
SYMBOL_TILDE                ~
SYMBOL_VERTICAL_BAR         |

#---------------------------------------------------------------------
[tokenizer]
#---------------------------------------------------------------------
<<tokenize>>
which (input)
  discardAny [whitespace]
endWhich

markSourcePosition
if (not hasAnother) halt

<tokenize_identifier>
if (scanIdentifier)
  which (buffer)
    produceAny [keywords]
    others: produce IDENTIFIER
  endWhich
endIf

<tokenize_numbers>
which (input)
  case "0b"
    count = 2
    clear buffer
    scan_integer
    produce BINARY_INTEGER
  case "0c"
    count = 8
    clear buffer
    scan_integer
    produce OCTAL_INTEGER
  case "0x"
    count = 16
    clear buffer
    scan_integer
    produce HEX_INTEGER
  others
    ch = peek
    if (ch is digit)
      count = 10
      scan_integer
      produce INTEGER
    endIf
endWhich

<tokenize_symbols>
which (input)
  produceAny [symbols]
  case '\n': produce EOL
  case '#'
    ch = read
    while (ch != '\n') ch = read
    discard
  case '"'
    goto scan_string
  case "''"
    goto scan_two_quote_string
  case '\''
    clear buffer
    scan_character
    consume('\'')
    produce CHARACTER
endWhich

syntaxError

<scan_integer>
while (ch is digit base count or ch == '_')
  ch = read
  if (ch != '_') collect ch
  if (not hasAnother) return
  ch = peek
endWhile
return


<scan_string>
clear buffer
while (hasAnother and not nextIs('"'))
  scan_character
endWhile
produce STRING

<scan_two_quote_string>
clear buffer
while (hasAnother)
  if (nextIs('\''))
    ch = peek(1)
    if (ch == '\'')
      ch = read
      ch = read
      produce STRING
    endIf
  endIf
  scan_character
endWhile
error "Unterminated two-quote string - expected '', found end of input."

<scan_character>
ch = read
if (ch == '\\')
  if (consume('b')) collect 8; return
  if (consume('e')) collect 27; return
  if (consume('f')) collect 12; return
  if (consume('n')) collect '\n'; return
  if (consume('r')) collect '\r'; return
  if (consume('t')) collect '\t'; return
  if (consume('v')) collect 11; return
  if (consume('0')) collect 0; return
  if (consume('/')) collect '/'; return
  if (consume('?')) collect '?'; return
  if (consume('\''))collect '\''; return
  if (consume('\\'))collect '\\'; return
  if (consume('"')) collect '"'; return
  if (consume('x'))
    if (ch = scanDigits 2 base 16) collect ch; return
    error "Expected 2-digit hex code after '\\x'."
  endIf
  if (consume('u'))
    if (ch = scanDigits 4 base 16) collect ch; return
    error "Expected 4-digit hex code after '\\u'."
  endIf
  if (consume('['))
    if (ch = scanDigits 1..6 base 16)
      mustConsume ']'
      collect ch
      return
    endIf
    error "Expected hex code with 1-6 digits after '\\['."
  endIf
  clear buffer
  collect "Invalid escape sequence '"
  collect '\\'
  collect ch
  collect "'. Supported: \\b \\e \\f \\n \\r \\t \\v \\0 \\? \\/ \\' \\\\ \\\" \\xHH \\uHHHH \\[H*]."
  error buffer
endIf
collect ch
return

#---------------------------------------------------------------------
#[parser]
#---------------------------------------------------------------------
