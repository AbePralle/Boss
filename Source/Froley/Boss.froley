#---------------------------------------------------------------------
[settings]
#---------------------------------------------------------------------
id_start    alpha '_'
id_continue alpha numeric '_'

#---------------------------------------------------------------------
[whitespace]
#---------------------------------------------------------------------
SPACE ' '
TAB   '\t'
CR    '\r'

#---------------------------------------------------------------------
[attributes]
#---------------------------------------------------------------------
structural

#---------------------------------------------------------------------
[tokens]
#---------------------------------------------------------------------
EOL            "\n"
BINARY_INTEGER integer      [content]
OCTAL_INTEGER  integer      [content]
HEX_INTEGER    integer      [content]
INTEGER        integer      [content]
REAL_NUMBER    real         [content]
STRING         string       [content]
IDENTIFIER     identifier   [content]


#---------------------------------------------------------------------
[keywords]
#---------------------------------------------------------------------
KEYWORD_AUGMENT     augment
KEYWORD_CLASS       class       [structural]
KEYWORD_MODULE      module
KEYWORD_ELSE        else        [structural]
KEYWORD_ELSE_IF     elseIf
KEYWORD_END_CLASS   endClass    [structural]
KEYWORD_END_IF      endIf       [structural]
KEYWORD_END_ROUTINE endRoutine  [structural]
KEYWORD_END_WHILE   endWhile    [structural]
KEYWORD_FALSE       false
KEYWORD_GLOBAL      global
KEYWORD_GLOBAL_PROPERTIES "GLOBAL PROPERTIES" [structural]
KEYWORD_GLOBAL_METHODS    "GLOBAL METHODS"    [structural]
KEYWORD_IF          if
KEYWORD_IMPORT      import
KEYWORD_LOCAL       local
KEYWORD_METHOD      method
KEYWORD_METHODS     METHODS     [structural]
KEYWORD_NULL        null
KEYWORD_PRINTLN     println
KEYWORD_PROPERTIES  PROPERTIES  [structural]
KEYWORD_RETURN      return
KEYWORD_ROUTINE     routine
KEYWORD_THIS_CALL   thisCall
KEYWORD_TRUE        true
KEYWORD_UNDEFINED   undefined
KEYWORD_USES        uses
KEYWORD_WHILE       while

#---------------------------------------------------------------------
[symbols]
#---------------------------------------------------------------------
SYMBOL_AMPERSAND            &
SYMBOL_ARROW                ->
SYMBOL_ASTERISK             *
SYMBOL_AT                   @
SYMBOL_BANG                 !
SYMBOL_CARET                ^
SYMBOL_CLOSE_BRACE          }   [structural]
SYMBOL_CLOSE_BRACKET        ]   [structural]
SYMBOL_CLOSE_PAREN          )   [structural]
SYMBOL_COLON                :   [structural]
SYMBOL_COLON_COLON          ::
SYMBOL_COMMA                ,   [structural]
SYMBOL_DOLLAR               $
SYMBOL_DOUBLE_VERTICAL_BAR  ||  [structural]
SYMBOL_EQ                   ==
SYMBOL_EQUALS               =
SYMBOL_GE                   >=
SYMBOL_GT                   >
SYMBOL_GT_GT                >>
SYMBOL_LE                   <=
SYMBOL_LEFT_SHIFT           :<<:
SYMBOL_LITERAL_OPEN_BRACKET @[
SYMBOL_LT                   <
SYMBOL_LT_LT                <<
SYMBOL_MINUS                -
SYMBOL_MINUS_MINUS          --
SYMBOL_NE                   !=
SYMBOL_OPEN_BRACE           {
SYMBOL_OPEN_BRACKET         [
SYMBOL_OPEN_PAREN           (
SYMBOL_PERCENT              %
SYMBOL_PERIOD               .
SYMBOL_PLUS                 +
SYMBOL_PLUS_PLUS            ++
SYMBOL_QUESTION             ?
SYMBOL_QUESTION_COLON       ?:
SYMBOL_RIGHT_SHIFT          :>>:
SYMBOL_RIGHT_SHIFT_X        :>>>:
SYMBOL_SEMICOLON            ;
SYMBOL_SLASH                /
SYMBOL_TILDE                ~
SYMBOL_VERTICAL_BAR         |

SYMBOL_PLUS_EQUALS          +=
SYMBOL_MINUS_EQUALS         -=
SYMBOL_TIMES_EQUALS         *=
SYMBOL_DIVIDE_EQUALS        /=
SYMBOL_MOD_EQUALS           %=
SYMBOL_AND_EQUALS           &=
SYMBOL_OR_EQUALS            |=

#---------------------------------------------------------------------
[tokenizer]
#---------------------------------------------------------------------
<<tokenize>>
which (input)
  discardAny [whitespace]
endWhich

markSourcePosition
if (not hasAnother)
  create EOL
  halt
endIf

<tokenize_identifier>
if (scanIdentifier)
  which (buffer)
    case "GLOBAL"
      while (consume(' ')) noAction
      if (scanIdentifier)
        which (buffer)
          case "PROPERTIES": produce KEYWORD_GLOBAL_PROPERTIES
          case "METHODS":    produce KEYWORD_GLOBAL_METHODS
        endWhich
      endIf
      syntaxError "Expected 'GLOBAL PROPERTIES' or 'GLOBAL METHODS'."
    produceAny [keywords]
    others: produce IDENTIFIER
  endWhich
endIf

clear buffer
tokenize_decimal

<tokenize_numbers>
which (input)
  case "0b"
    count = 2
    clear buffer
    scan_integer
    produce BINARY_INTEGER
  case "0c"
    count = 8
    clear buffer
    scan_integer
    produce OCTAL_INTEGER
  case "0x"
    count = 16
    clear buffer
    scan_integer
    produce HEX_INTEGER
  others
    ch = peek
    if (ch is digit)
      count = 10
      scan_integer
      if (nextIs('.'))
        tokenize_decimal
      elseIf (nextIs('e') or nextIs('E'))
        tokenize_exponent
      else
        produce INTEGER
      endIf
    endIf
endWhich

<tokenize_symbols>
which (input)
  produceAny [symbols]
  case '\n': produce EOL
  case "#{": consume_comment_span; restart
  case '#'
    ch = read
    while (ch != '\n') ch = read
    discard
  case '"'
    goto tokenize_string
  case "'"
    goto tokenize_single_quote_string
  case "''"
    goto tokenize_two_quote_string
  case '\''
    clear buffer
    scan_character
    consume('\'')
    produce CHARACTER
  case "@|"
    tokenize_verbatim_string
endWhich

syntaxError

<scan_integer>
while (hasAnother)
  ch = peek
  if (ch is digit base count or ch == '_')
    ch = read
    if (ch != '_') collect ch
  else
    return
  endIf
endWhile
return

<tokenize_decimal>
ch = peek
if (ch != '.') return
ch = peek( 1 )
if (ch is not digit) return
ch = read
collect ch
ch = read
collect ch

# Real number starting from .
while (hasAnother)
  ch = peek
  if (ch is digit)
    ch = read
    collect ch
  elseIf (ch == 'e' or ch == 'E')
    tokenize_exponent
  else
    produce REAL_NUMBER
  endIf
endWhile
produce REAL_NUMBER

<tokenize_exponent>
ch = read  # 'e' or 'E'
collect ch
if (consume('-'))     collect '-'
elseIf (consume('+')) collect '+'
ch = peek
if (ch is not digit) syntaxError "Syntax error - at least one digit is expected after the exponent."
count = 10  # base 10
scan_integer
produce REAL_NUMBER

<tokenize_string>
clear buffer
while (hasAnother and not nextIs('"'))
  scan_character
endWhile
mustConsume '"'
produce STRING

<tokenize_single_quote_string>
clear buffer
while (hasAnother and not nextIs('\''))
  scan_character
endWhile
mustConsume '\''
produce STRING

<tokenize_two_quote_string>
clear buffer
while (hasAnother)
  if (nextIs('\''))
    ch = peek(1)
    if (ch == '\'')
      ch = read
      ch = read
      produce STRING
    endIf
  endIf
  scan_character
endWhile
syntaxError "Unterminated two-quote string - expected '', found end of input."

<scan_character>
ch = read
if (ch == '\n')
  syntaxError "Unterminated string - unexpected end of line."
endIf
if (ch == '\\')
  if (consume('b')) collect 8; return
  if (consume('e')) collect 27; return
  if (consume('f')) collect 12; return
  if (consume('n')) collect '\n'; return
  if (consume('r')) collect '\r'; return
  if (consume('t')) collect '\t'; return
  if (consume('v')) collect 11; return
  if (consume('0')) collect 0; return
  if (consume('/')) collect '/'; return
  if (consume('?')) collect '?'; return
  if (consume('\''))collect '\''; return
  if (consume('\\'))collect '\\'; return
  if (consume('"')) collect '"'; return
  if (consume('x'))
    if (ch = scanDigits 2 base 16) collect ch; return
    syntaxError "Expected 2-digit hex code after '\\x'."
  endIf
  if (consume('u'))
    if (ch = scanDigits 4 base 16) collect ch; return
    syntaxError "Expected 4-digit hex code after '\\u'."
  endIf
  if (consume('['))
    if (ch = scanDigits 1..6 base 16)
      mustConsume ']'
      collect ch
      return
    endIf
    syntaxError "Expected hex code with 1-6 digits after '\\['."
  endIf
  clear buffer
  collect "Invalid escape sequence '"
  collect '\\'
  collect ch
  collect "'. Supported: \\b \\e \\f \\n \\r \\t \\v \\0 \\? \\/ \\' \\\\ \\\" \\xHH \\uHHHH \\[H*]."
  syntaxError buffer
endIf
collect ch
return

<tokenize_verbatim_string>
clear buffer
while (hasAnother)
  if (consume('\n'))
    collect '\n'
    while (consume(' '))
    endWhile
    if (not consume('|')) produce STRING
  else
    ch = read
    collect ch
  endIf
endWhile
produce STRING

<consume_comment_span>
while (hasAnother)
  which (input)
    case "#{"
      consume_comment_span
    case "}#"
      return
    others
      ch = read  # discard
  endWhich
endWhile

#---------------------------------------------------------------------
[parser]
#---------------------------------------------------------------------
- parse_element
  while (consume(EOL)) noAction
  if (not hasAnother) return

  on "class", parse_class -> CmdClassDefinition( name, base_classes, attributes, elements )
  on "module", parse_module_name, EOL -> CmdModuleDeclaration(name )

  parse_statement_with_eol

- consume_eols
  while (consume(EOL)) noAction

- parse_class
  parse_identifier
  parse_base_classes
  parse_class_attributes
  parse_class_sections
  mustConsume "endClass"

- parse_base_classes
  beginList
  if (not consume(':')) produceList
  parse_type
  while (consume(','))
    consume_eols
    parse_type
  endWhile
  produceList

- parse_class_attributes
  beginList
  if (not consume('[')) produceList
  parse_identifier
  consume_eols
  while (not nextIs(']'))
    parse_identifier
    consume_eols
  endWhile
  mustConsume ']'
  produceList

- parse_class_sections
  beginList
  if (not consume(';'))
    while (not nextIs("endClass")) parse_class_section
  endIf
  produceList

- parse_class_section
  consume_eols
  on "GLOBAL PROPERTIES"
    consume_eols
    while (not nextHasAttribute(structural))
      parse_properties
    endWhile
    return
  elseOn "GLOBAL METHODS"
    consume_eols
    while (nextIs("method"))
      parse_method
      consume_eols
    endWhile
    return
  elseOn "PROPERTIES"
    consume_eols
    while (not nextHasAttribute(structural))
      parse_properties
    endWhile
    return
  elseOn "METHODS"
    consume_eols
    while (nextIs("method"))
      parse_method
      consume_eols
    endWhile
    return
  endOn
  if (not nextIs("endClass")) syntaxError

- parse_identifier
  on IDENTIFIER -> CmdIdentifier( value=t.content:String )
  mustConsume IDENTIFIER

- parse_method
  on "method", parse_identifier, parse_method_parameters, parse_method_return_type, parse_method_body ->
    CmdMethod(_name,parameters,return_type,body)

- parse_method_parameters
  beginList
  produceList

- parse_method_return_type
  produceNull

- parse_method_body
  beginList
  produceStatements

- parse_module_name : BinaryParseRule
  on "::" -> CmdScope

+ parse_module_segment
  parse_identifier

- parse_properties
  consume_eols
  onPeek IDENTIFIER, parse_var_declarations, mustConsume(EOL) -> CmdProperties( declarations, type )

- parse_statement
  on "global", parse_var_declarations -> CmdGlobalDeclarations( declarations, type )
  on "local",  parse_var_declarations -> CmdLocalDeclarations( declarations, type )
  syntaxError

- parse_statement_with_eol
  parse_statement
  mustConsume( EOL )

- parse_type
  on IDENTIFIER -> CmdType( name=t.content:String )
  mustConsume IDENTIFIER

- parse_var_declarations
  beginList
  consume_eols
  parse_var_declaration
  while (consume(','))
    consume_eols
    parse_var_declaration
  endWhile
  createList
  if (consume(':'))
    parse_type
  else
    createNull
  endIf

- parse_var_declaration
  on IDENTIFIER
    if (consume('=')) consume_eols; parse_expression
    else              createNull
    produce CmdVarDeclaration( name=t.content:String, initial_value )
  endOn
  mustConsume IDENTIFIER

- parse_expression

+ parse_assign : RightAssociativeBinaryParseRule
  on "="  -> CmdAssign
  on "+=" -> CmdAddAndAssign
  on "-=" -> CmdSubtractAndAssign
  on "*=" -> CmdMultiplyAndAssign
  on "/=" -> CmdDivideAndAssign
  on "%=" -> CmdModAndAssign
  on "&=" -> CmdAndAndAssign
  on "|=" -> CmdOrAndAssign

+ parse_logical_xor  : BinaryParseRule

+ parse_logical_or   : BinaryParseRule

+ parse_logical_and  : BinaryParseRule

+ parse_comparison : BinaryParseRule
  on "==" -> CmdCompareEQ
  on "!=" -> CmdCompareNE
  on "<"  -> CmdCompareLT
  on ">"  -> CmdCompareGT
  on "<=" -> CmdCompareLE
  on ">=" -> CmdCompareGE

+ parse_bitwise_xor : BinaryParseRule

+ parse_bitwise_or  : BinaryParseRule

+ parse_bitwise_and : BinaryParseRule

+ parse_bitwise_shift : BinaryParseRule

+ parse_add_subtract : BinaryParseRule
  on "+" -> CmdAdd
  on "-" -> CmdSubtract

+ parse_multiply_divide : BinaryParseRule
  on "*" -> CmdMultiply
  on "/" -> CmdDivide

+ parse_pre_unary : PreUnaryParseRule
  on "-"  -> CmdNegate
  on "++" -> CmdPreIncrement
  on "--" -> CmdPreDecrement

+ parse_post_unary : PostUnaryParseRule
  on "++" -> CmdPostIncrement
  on "--" -> CmdPostDecrement

+ access : BinaryParseRule

+ term
  on IDENTIFIER -> CmdAccess( value=t.content:String )
  on INTEGER    -> CmdLiteralInt32( value=t.content:Int32 )
  on '(', expression, ')': return
  syntaxError

