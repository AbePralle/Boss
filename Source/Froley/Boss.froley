#---------------------------------------------------------------------
[settings]
#---------------------------------------------------------------------
id_start    alpha '_'
id_continue alpha numeric '_'

#---------------------------------------------------------------------
[whitespace]
#---------------------------------------------------------------------
SPACE ' '
TAB   '\t'
CR    '\r'

#---------------------------------------------------------------------
[attributes]
#---------------------------------------------------------------------
structural

#---------------------------------------------------------------------
[tokens]
#---------------------------------------------------------------------
EOL            "\n"
BINARY_INTEGER integer      [content]
OCTAL_INTEGER  integer      [content]
HEX_INTEGER    integer      [content]
INTEGER        integer      [content]
REAL_NUMBER    real         [content]
STRING         string       [content]
IDENTIFIER     identifier   [content]


#---------------------------------------------------------------------
[keywords]
#---------------------------------------------------------------------
KEYWORD_AUGMENT     augment
KEYWORD_CLASS       class
KEYWORD_ELSE        else
KEYWORD_ELSE_IF     elseIf
KEYWORD_END_CLASS   endClass
KEYWORD_END_IF      endIf
KEYWORD_END_ROUTINE endRoutine
KEYWORD_END_WHILE   endWhile
KEYWORD_FALSE       false
KEYWORD_GLOBAL      global
KEYWORD_IF          if
KEYWORD_IMPORT      import
KEYWORD_LOCAL       local
KEYWORD_METHOD      method
KEYWORD_METHODS     METHODS
KEYWORD_NULL        null
KEYWORD_PRINTLN     println
KEYWORD_PROPERTIES  PROPERTIES
KEYWORD_RETURN      return
KEYWORD_ROUTINE     routine
KEYWORD_THIS_CALL   thisCall
KEYWORD_TRUE        true
KEYWORD_UNDEFINED   undefined
KEYWORD_WHILE       while

#---------------------------------------------------------------------
[symbols]
#---------------------------------------------------------------------
SYMBOL_AMPERSAND            &
SYMBOL_ARROW                ->
SYMBOL_ASTERISK             *
SYMBOL_AT                   @
SYMBOL_BANG                 !
SYMBOL_CARET                ^
SYMBOL_CLOSE_BRACE          }   [structural]
SYMBOL_CLOSE_BRACKET        ]   [structural]
SYMBOL_CLOSE_PAREN          )   [structural]
SYMBOL_COLON                :   [structural]
SYMBOL_COLON_COLON          ::
SYMBOL_COMMA                ,   [structural]
SYMBOL_DOLLAR               $
SYMBOL_DOUBLE_VERTICAL_BAR  ||  [structural]
SYMBOL_EQ                   ==
SYMBOL_EQUALS               =
SYMBOL_GE                   >=
SYMBOL_GT                   >
SYMBOL_GT_GT                >>
SYMBOL_LE                   <=
SYMBOL_LEFT_SHIFT           :<<:
SYMBOL_LITERAL_OPEN_BRACKET @[
SYMBOL_LT                   <
SYMBOL_LT_LT                <<
SYMBOL_MINUS                -
SYMBOL_MINUS_MINUS          --
SYMBOL_NE                   !=
SYMBOL_OPEN_BRACE           {
SYMBOL_OPEN_BRACKET         [
SYMBOL_OPEN_PAREN           (
SYMBOL_PERCENT              %
SYMBOL_PERIOD               .
SYMBOL_PLUS                 +
SYMBOL_PLUS_PLUS            ++
SYMBOL_QUESTION             ?
SYMBOL_QUESTION_COLON       ?:
SYMBOL_RIGHT_SHIFT          :>>:
SYMBOL_RIGHT_SHIFT_X        :>>>:
SYMBOL_SEMICOLON            ;
SYMBOL_SLASH                /
SYMBOL_TILDE                ~
SYMBOL_VERTICAL_BAR         |

SYMBOL_PLUS_EQUALS          +=
SYMBOL_MINUS_EQUALS         -=
SYMBOL_TIMES_EQUALS         *=
SYMBOL_DIVIDE_EQUALS        /=
SYMBOL_MOD_EQUALS           %=
SYMBOL_AND_EQUALS           &=
SYMBOL_OR_EQUALS            |=

#---------------------------------------------------------------------
[tokenizer]
#---------------------------------------------------------------------
<<tokenize>>
which (input)
  discardAny [whitespace]
endWhich

markSourcePosition
if (not hasAnother)
  create EOL
  halt
endIf

<tokenize_identifier>
if (scanIdentifier)
  which (buffer)
    produceAny [keywords]
    others: produce IDENTIFIER
  endWhich
endIf

clear buffer
tokenize_decimal

<tokenize_numbers>
which (input)
  case "0b"
    count = 2
    clear buffer
    scan_integer
    produce BINARY_INTEGER
  case "0c"
    count = 8
    clear buffer
    scan_integer
    produce OCTAL_INTEGER
  case "0x"
    count = 16
    clear buffer
    scan_integer
    produce HEX_INTEGER
  others
    ch = peek
    if (ch is digit)
      count = 10
      scan_integer
      if (nextIs('.'))
        tokenize_decimal
      elseIf (nextIs('e') or nextIs('E'))
        tokenize_exponent
      else
        produce INTEGER
      endIf
    endIf
endWhich

<tokenize_symbols>
which (input)
  produceAny [symbols]
  case '\n': produce EOL
  case "#{": consume_comment_span; restart
  case '#'
    ch = read
    while (ch != '\n') ch = read
    discard
  case '"'
    goto tokenize_string
  case "'"
    goto tokenize_single_quote_string
  case "''"
    goto tokenize_two_quote_string
  case '\''
    clear buffer
    scan_character
    consume('\'')
    produce CHARACTER
  case "@|"
    tokenize_verbatim_string
endWhich

syntaxError

<scan_integer>
while (hasAnother)
  ch = peek
  if (ch is digit base count or ch == '_')
    ch = read
    if (ch != '_') collect ch
  else
    return
  endIf
endWhile
return

<tokenize_decimal>
ch = peek
if (ch != '.') return
ch = peek( 1 )
if (ch is not digit) return
ch = read
collect ch
ch = read
collect ch

# Real number starting from .
while (hasAnother)
  ch = peek
  if (ch is digit)
    ch = read
    collect ch
  elseIf (ch == 'e' or ch == 'E')
    tokenize_exponent
  else
    produce REAL_NUMBER
  endIf
endWhile
produce REAL_NUMBER

<tokenize_exponent>
ch = read  # 'e' or 'E'
collect ch
if (consume('-'))     collect '-'
elseIf (consume('+')) collect '+'
ch = peek
if (ch is not digit) error "Syntax error - at least one digit is expected after the exponent."
count = 10  # base 10
scan_integer
produce REAL_NUMBER

<tokenize_string>
clear buffer
while (hasAnother and not nextIs('"'))
  scan_character
endWhile
mustConsume '"'
produce STRING

<tokenize_single_quote_string>
clear buffer
while (hasAnother and not nextIs('\''))
  scan_character
endWhile
mustConsume '\''
produce STRING

<tokenize_two_quote_string>
clear buffer
while (hasAnother)
  if (nextIs('\''))
    ch = peek(1)
    if (ch == '\'')
      ch = read
      ch = read
      produce STRING
    endIf
  endIf
  scan_character
endWhile
error "Unterminated two-quote string - expected '', found end of input."

<scan_character>
ch = read
if (ch == '\n')
  error "Unterminated string - unexpected end of line."
endIf
if (ch == '\\')
  if (consume('b')) collect 8; return
  if (consume('e')) collect 27; return
  if (consume('f')) collect 12; return
  if (consume('n')) collect '\n'; return
  if (consume('r')) collect '\r'; return
  if (consume('t')) collect '\t'; return
  if (consume('v')) collect 11; return
  if (consume('0')) collect 0; return
  if (consume('/')) collect '/'; return
  if (consume('?')) collect '?'; return
  if (consume('\''))collect '\''; return
  if (consume('\\'))collect '\\'; return
  if (consume('"')) collect '"'; return
  if (consume('x'))
    if (ch = scanDigits 2 base 16) collect ch; return
    error "Expected 2-digit hex code after '\\x'."
  endIf
  if (consume('u'))
    if (ch = scanDigits 4 base 16) collect ch; return
    error "Expected 4-digit hex code after '\\u'."
  endIf
  if (consume('['))
    if (ch = scanDigits 1..6 base 16)
      mustConsume ']'
      collect ch
      return
    endIf
    error "Expected hex code with 1-6 digits after '\\['."
  endIf
  clear buffer
  collect "Invalid escape sequence '"
  collect '\\'
  collect ch
  collect "'. Supported: \\b \\e \\f \\n \\r \\t \\v \\0 \\? \\/ \\' \\\\ \\\" \\xHH \\uHHHH \\[H*]."
  error buffer
endIf
collect ch
return

<tokenize_verbatim_string>
clear buffer
while (hasAnother)
  if (consume('\n'))
    collect '\n'
    while (consume(' '))
    endWhile
    if (not consume('|')) produce STRING
  else
    ch = read
    collect ch
  endIf
endWhile
produce STRING

<consume_comment_span>
while (hasAnother)
  which (input)
    case "#{"
      consume_comment_span
    case "}#"
      return
    others
      ch = read  # discard
  endWhich
endWhile

#---------------------------------------------------------------------
[parser]
#---------------------------------------------------------------------
- parse_element
  while (consume(EOL)) noAction
  if (not hasAnother) return
  parse_statement_with_eol

- parse_statement_with_eol
  parse_statement
  mustConsume( EOL )

- consume_eols
  while (consume(EOL)) noAction

- parse_statement
  on "local"
    beginList
    consume_eols
    parse_local_declaration
    while (consume(','))
      consume_eols
      parse_local_declaration
    endWhile
    createList
    if (consume(':'))
      parse_type
    else
      createNull
    endIf
    produce CmdLocalDeclarations( declarations, type )
  endOn
  syntaxError

- parse_local_declaration
  on IDENTIFIER
    if (consume('=')) consume_eols; parse_expression
    else              createNull
    produce CmdLocalDeclaration( name=t.content:String, initial_value )
  endOn
  mustConsume IDENTIFIER

- parse_type
  on IDENTIFIER -> CmdType( name=t.content:String )
  mustConsume IDENTIFIER

- parse_expression

+ parse_assign : RightAssociativeBinaryParseRule
  on "="  -> CmdAssign
  on "+=" -> CmdAddAndAssign
  on "-=" -> CmdSubtractAndAssign
  on "*=" -> CmdMultiplyAndAssign
  on "/=" -> CmdDivideAndAssign
  on "%=" -> CmdModAndAssign
  on "&=" -> CmdAndAndAssign
  on "|=" -> CmdOrAndAssign

+ parse_logical_xor  : BinaryParseRule

+ parse_logical_or   : BinaryParseRule

+ parse_logical_and  : BinaryParseRule

+ parse_comparison : BinaryParseRule
  on "==" -> CmdCompareEQ
  on "!=" -> CmdCompareNE
  on "<"  -> CmdCompareLT
  on ">"  -> CmdCompareGT
  on "<=" -> CmdCompareLE
  on ">=" -> CmdCompareGE

+ parse_bitwise_xor : BinaryParseRule

+ parse_bitwise_or  : BinaryParseRule

+ parse_bitwise_and : BinaryParseRule

+ parse_bitwise_shift : BinaryParseRule

+ parse_add_subtract : BinaryParseRule
  on "+" -> CmdAdd
  on "-" -> CmdSubtract

+ parse_multiply_divide : BinaryParseRule
  on "*" -> CmdMultiply
  on "/" -> CmdDivide

+ parse_pre_unary : PreUnaryParseRule
  on "-"  -> CmdNegate
  on "++" -> CmdPreIncrement
  on "--" -> CmdPreDecrement

+ parse_post_unary : PostUnaryParseRule
  on "++" -> CmdPostIncrement
  on "--" -> CmdPostDecrement

+ access : BinaryParseRule

+ term
  on IDENTIFIER -> CmdAccess( value=t.content:String )
  on INTEGER    -> CmdLiteralInt32( value=t.content:Int32 )
  on '(', expression, ')': return
  syntaxError

